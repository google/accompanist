{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Accompanist is a group of libraries that aim to supplement Jetpack Compose with features that are commonly required by developers but not yet available. Accompanist is a labs like environment for new Compose APIs. We use it to help fill known gaps in the Compose toolkit, experiment with new APIs and to gather insight into the development experience of developing a Compose library. The goal of these libraries is to upstream them into the official toolkit, at which point they will be deprecated and removed from Accompanist. For more details like, why does this library exist? Why is it not part of AndroidX? Will you be releasing more libraries? Check out our Accompanist FAQ . Compose versions \u00b6 Each release outlines what version of the Compose UI libraries it depends on. We are currently releasing multiple versions of Accompanist for the different versions of Compose: Compose 1.0 (1.0.x) Compose 1.1 (1.1.x) Compose UI 1.2 (1.2.x) Compose UI 1.3 (1.3.x) For stable versions of Compose, we use the latest stable version of the Compose compiler. For non-stable versions (alpha, beta, etc), we use the latest compiler at the time of release. :warning: Ensure you are using the Accompanist version that matches with your Compose UI version : If you upgrade Accompanist, it will upgrade your Compose libraries version via transitive dependencies. Libraries \u00b6 \ud83c\udf6b System UI Controller \u00b6 A library that provides easy-to-use utilities for recoloring the Android system bars from Jetpack Compose. \ud83c\udfa8 AppCompat Theme Adapter \u00b6 A library that enables the reuse of AppCompat XML themes for theming in Jetpack Compose. \ud83d\udcd6 Pager \u00b6 A library that provides utilities for building paginated layouts in Jetpack Compose, similar to Android's ViewPager . \ud83d\udceb Permissions \u00b6 A library that provides Android runtime permissions support for Jetpack Compose. \u23f3 Placeholder \u00b6 A library that provides easy-to-use modifiers for displaying a placeholder UI while content is loading. \ud83c\udf0a Flow Layouts \u00b6 A library that adds Flexbox-like layout components to Jetpack Compose. \ud83e\udded\u2728 Navigation-Animation \u00b6 A library which provides Compose Animation support for Jetpack Navigation Compose. \ud83e\udded\ud83c\udfa8\ufe0f Navigation-Material \u00b6 A library which provides Compose Material support, such as modal bottom sheets, for Jetpack Navigation Compose. \ud83d\udd8c\ufe0f Drawable Painter \u00b6 A library which provides a way to use Android Drawables as Jetpack Compose Painters. \u2b07\ufe0f Swipe to Refresh \u00b6 A library that provides a layout implementing the swipe-to-refresh UX pattern, similar to Android's SwipeRefreshLayout . \ud83c\udf0f Web \u00b6 A wrapper around WebView for basic WebView support in Jetpack Compose. \ud83d\udcdc Adaptive \u00b6 A library providing a collection of utilities for adaptive layouts. \ud83d\udcd0 Insets (Deprecated) \u00b6 See our Migration Guide for migrating to Insets in Compose. Future? \u00b6 Any of the features available in this group of libraries may become obsolete in the future, at which point they will (probably) become deprecated. We will aim to provide a migration path (where possible), to whatever supersedes the functionality. Snapshots \u00b6 Snapshots of the current development version of Accompanist are available, which track the latest commit. See here for more information. Why the name? \u00b6 The library is all about adding some utilities around Compose. Music composing is done by a composer, and since this library is about supporting composition, the supporting role of an accompanist felt like a good name. Contributions \u00b6 Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though. License \u00b6 Copyright 2020 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#compose-versions","text":"Each release outlines what version of the Compose UI libraries it depends on. We are currently releasing multiple versions of Accompanist for the different versions of Compose: Compose 1.0 (1.0.x) Compose 1.1 (1.1.x) Compose UI 1.2 (1.2.x) Compose UI 1.3 (1.3.x) For stable versions of Compose, we use the latest stable version of the Compose compiler. For non-stable versions (alpha, beta, etc), we use the latest compiler at the time of release. :warning: Ensure you are using the Accompanist version that matches with your Compose UI version : If you upgrade Accompanist, it will upgrade your Compose libraries version via transitive dependencies.","title":"Compose versions"},{"location":"#libraries","text":"","title":"Libraries"},{"location":"#system-ui-controller","text":"A library that provides easy-to-use utilities for recoloring the Android system bars from Jetpack Compose.","title":"\ud83c\udf6b System UI Controller"},{"location":"#appcompat-theme-adapter","text":"A library that enables the reuse of AppCompat XML themes for theming in Jetpack Compose.","title":"\ud83c\udfa8 AppCompat Theme Adapter"},{"location":"#pager","text":"A library that provides utilities for building paginated layouts in Jetpack Compose, similar to Android's ViewPager .","title":"\ud83d\udcd6 Pager"},{"location":"#permissions","text":"A library that provides Android runtime permissions support for Jetpack Compose.","title":"\ud83d\udceb Permissions"},{"location":"#placeholder","text":"A library that provides easy-to-use modifiers for displaying a placeholder UI while content is loading.","title":"\u23f3 Placeholder"},{"location":"#flow-layouts","text":"A library that adds Flexbox-like layout components to Jetpack Compose.","title":"\ud83c\udf0a Flow Layouts"},{"location":"#navigation-animation","text":"A library which provides Compose Animation support for Jetpack Navigation Compose.","title":"\ud83e\udded\u2728Navigation-Animation"},{"location":"#navigation-material","text":"A library which provides Compose Material support, such as modal bottom sheets, for Jetpack Navigation Compose.","title":"\ud83e\udded\ud83c\udfa8\ufe0f Navigation-Material"},{"location":"#drawable-painter","text":"A library which provides a way to use Android Drawables as Jetpack Compose Painters.","title":"\ud83d\udd8c\ufe0f Drawable Painter"},{"location":"#swipe-to-refresh","text":"A library that provides a layout implementing the swipe-to-refresh UX pattern, similar to Android's SwipeRefreshLayout .","title":"\u2b07\ufe0f Swipe to Refresh"},{"location":"#web","text":"A wrapper around WebView for basic WebView support in Jetpack Compose.","title":"\ud83c\udf0f Web"},{"location":"#adaptive","text":"A library providing a collection of utilities for adaptive layouts.","title":"\ud83d\udcdc Adaptive"},{"location":"#insets-deprecated","text":"See our Migration Guide for migrating to Insets in Compose.","title":"\ud83d\udcd0 Insets (Deprecated)"},{"location":"#future","text":"Any of the features available in this group of libraries may become obsolete in the future, at which point they will (probably) become deprecated. We will aim to provide a migration path (where possible), to whatever supersedes the functionality.","title":"Future?"},{"location":"#snapshots","text":"Snapshots of the current development version of Accompanist are available, which track the latest commit. See here for more information.","title":"Snapshots"},{"location":"#why-the-name","text":"The library is all about adding some utilities around Compose. Music composing is done by a composer, and since this library is about supporting composition, the supporting role of an accompanist felt like a good name.","title":"Why the name?"},{"location":"#contributions","text":"Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though.","title":"Contributions"},{"location":"#license","text":"Copyright 2020 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"adaptive/","text":"Adaptive utilities for Jetpack Compose \u00b6 A library providing a collection of utilities for adaptive layouts. calculateDisplayFeatures \u00b6 calculateDisplayFeatures(activity) returns the current list of DisplayFeature s, as reported by the Jetpack WindowManager library . These contain the list of folds (if any), and can be used to drive components like TwoPane . TwoPane \u00b6 TwoPane is a UI component that positions exactly two slots on the screen. The default positioning of these two slots is driven by a TwoPaneStrategy , which can decide to orient the two slots side-by-side horizontally or vertically, and also configure the gap between them. The built-in HorizontalTwoPaneStrategy and VerticalTwoPaneStrategy allow positioning the slots based on a fixed offset, or as some fraction of the space. TwoPane also requires a list of display features (to be retrieved with calculateDisplayFeatures ), and optionally a FoldAwareConfiguration to determine which folds to handle automatically. When there is a fold that intersects with the TwoPane component that is obscuring or separating, the TwoPane will automatically place the slots to avoid the fold. When there is no fold, the default supplied strategy will be used instead. Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-adaptive:<version>\" }","title":"Guide"},{"location":"adaptive/#adaptive-utilities-for-jetpack-compose","text":"A library providing a collection of utilities for adaptive layouts.","title":"Adaptive utilities for Jetpack Compose"},{"location":"adaptive/#calculatedisplayfeatures","text":"calculateDisplayFeatures(activity) returns the current list of DisplayFeature s, as reported by the Jetpack WindowManager library . These contain the list of folds (if any), and can be used to drive components like TwoPane .","title":"calculateDisplayFeatures"},{"location":"adaptive/#twopane","text":"TwoPane is a UI component that positions exactly two slots on the screen. The default positioning of these two slots is driven by a TwoPaneStrategy , which can decide to orient the two slots side-by-side horizontally or vertically, and also configure the gap between them. The built-in HorizontalTwoPaneStrategy and VerticalTwoPaneStrategy allow positioning the slots based on a fixed offset, or as some fraction of the space. TwoPane also requires a list of display features (to be retrieved with calculateDisplayFeatures ), and optionally a FoldAwareConfiguration to determine which folds to handle automatically. When there is a fold that intersects with the TwoPane component that is obscuring or separating, the TwoPane will automatically place the slots to avoid the fold. When there is no fold, the default supplied strategy will be used instead.","title":"TwoPane"},{"location":"adaptive/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-adaptive:<version>\" }","title":"Download"},{"location":"appcompat-theme/","text":"AppCompat Compose Theme Adapter \u00b6 A library that enables reuse of AppCompat XML themes for theming in Jetpack Compose . The basis of theming in Jetpack Compose is the MaterialTheme composable, where you provide Colors , Shapes and Typography instances containing your styling parameters: MaterialTheme ( typography = type , colors = colors , shapes = shapes ) { // Surface, Scaffold, etc } AppCompat XML themes allow for similar but coarser theming via XML theme attributes, like so: <style name= \"Theme.MyApp\" parent= \"Theme.AppCompat.DayNight\" > <item name= \"colorPrimary\" > @color/purple_500 </item> <item name= \"colorAccent\" > @color/green_200 </item> </style> This library attempts to bridge the gap between AppCompat XML themes, and themes in Jetpack Compose , allowing your composable MaterialTheme to be based on the Activity 's XML theme: AppCompatTheme { // MaterialTheme.colors, MaterialTheme.shapes, MaterialTheme.typography // will now contain copies of the context's theme } This is especially handy when you're migrating an existing app, a fragment (or other UI container) at a time. Caution If you are using Material Design Components in your app, you should use the MDC Compose Theme Adapter instead, as it allows much finer-grained reading of your theme. Customizing the theme \u00b6 The AppCompatTheme() function will automatically read the host context's AppCompat theme and pass them to MaterialTheme on your behalf, but if you want to customize the generated values, you can do so via the createAppCompatTheme() function: val context = LocalContext . current var ( colors , type ) = context . createAppCompatTheme () // Modify colors or type as required. Then pass them // through to MaterialTheme... MaterialTheme ( colors = colors , typography = type ) { // rest of layout } Generated theme \u00b6 Synthesizing a material theme from a Theme.AppCompat theme is not perfect, since Theme.AppCompat does not expose the same level of customization as is available in material theming. Going through the pillars of material theming: Colors \u00b6 AppCompat has a limited set of top-level color attributes, which means that AppCompatTheme() has to generate/select alternative colors in certain situations. The mapping is currently: MaterialTheme color AppCompat attribute primary colorPrimary primaryVariant colorPrimaryDark onPrimary Calculated black/white secondary colorAccent secondaryVariant colorAccent onSecondary Calculated black/white surface Default onSurface android:textColorPrimary , else calculated black/white background android:colorBackground onBackground android:textColorPrimary , else calculated black/white error colorError onError Calculated black/white Where the table says \"calculated black/white\", this means either black/white, depending on which provides the greatest contrast against the corresponding background color. Typography \u00b6 AppCompat does not provide any semantic text appearances (such as headline6, body1, etc), and instead relies on text appearances for specific widgets or use cases. As such, the only thing we read from an AppCompat theme is the default app:fontFamily or android:fontFamily . For example: <style name= \"Theme.MyApp\" parent= \"Theme.AppCompat\" > <item name= \"fontFamily\" > @font/my_font </item> </style> Compose does not currently support downloadable fonts, so any font referenced from the theme should from your resources. See here for more information. Shape \u00b6 AppCompat has no concept of shape theming, therefore we use the default value from MaterialTheme.shapes . If you wish to provide custom values, use the shapes parameter on AppCompatTheme . Limitations \u00b6 There are some known limitations with the implementation at the moment: This relies on your Activity / Context theme extending one of the Theme.AppCompat themes. Variable fonts are not supported in Compose yet, meaning that the value of android:fontVariationSettings are currently ignored. You can modify the resulting MaterialTheme in Compose as required, but this only works in Compose. Any changes you make will not be reflected in the Activity theme. Usage \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-appcompat-theme:<version>\" } Library Snapshots \u00b6 Snapshots of the current development version of this library are available, which track the latest commit. See here for more information on how to use them. Contributions \u00b6 Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though. License \u00b6 Copyright 2020 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Guide"},{"location":"appcompat-theme/#appcompat-compose-theme-adapter","text":"A library that enables reuse of AppCompat XML themes for theming in Jetpack Compose . The basis of theming in Jetpack Compose is the MaterialTheme composable, where you provide Colors , Shapes and Typography instances containing your styling parameters: MaterialTheme ( typography = type , colors = colors , shapes = shapes ) { // Surface, Scaffold, etc } AppCompat XML themes allow for similar but coarser theming via XML theme attributes, like so: <style name= \"Theme.MyApp\" parent= \"Theme.AppCompat.DayNight\" > <item name= \"colorPrimary\" > @color/purple_500 </item> <item name= \"colorAccent\" > @color/green_200 </item> </style> This library attempts to bridge the gap between AppCompat XML themes, and themes in Jetpack Compose , allowing your composable MaterialTheme to be based on the Activity 's XML theme: AppCompatTheme { // MaterialTheme.colors, MaterialTheme.shapes, MaterialTheme.typography // will now contain copies of the context's theme } This is especially handy when you're migrating an existing app, a fragment (or other UI container) at a time. Caution If you are using Material Design Components in your app, you should use the MDC Compose Theme Adapter instead, as it allows much finer-grained reading of your theme.","title":"AppCompat Compose Theme Adapter"},{"location":"appcompat-theme/#customizing-the-theme","text":"The AppCompatTheme() function will automatically read the host context's AppCompat theme and pass them to MaterialTheme on your behalf, but if you want to customize the generated values, you can do so via the createAppCompatTheme() function: val context = LocalContext . current var ( colors , type ) = context . createAppCompatTheme () // Modify colors or type as required. Then pass them // through to MaterialTheme... MaterialTheme ( colors = colors , typography = type ) { // rest of layout }","title":"Customizing the theme"},{"location":"appcompat-theme/#generated-theme","text":"Synthesizing a material theme from a Theme.AppCompat theme is not perfect, since Theme.AppCompat does not expose the same level of customization as is available in material theming. Going through the pillars of material theming:","title":"Generated theme"},{"location":"appcompat-theme/#colors","text":"AppCompat has a limited set of top-level color attributes, which means that AppCompatTheme() has to generate/select alternative colors in certain situations. The mapping is currently: MaterialTheme color AppCompat attribute primary colorPrimary primaryVariant colorPrimaryDark onPrimary Calculated black/white secondary colorAccent secondaryVariant colorAccent onSecondary Calculated black/white surface Default onSurface android:textColorPrimary , else calculated black/white background android:colorBackground onBackground android:textColorPrimary , else calculated black/white error colorError onError Calculated black/white Where the table says \"calculated black/white\", this means either black/white, depending on which provides the greatest contrast against the corresponding background color.","title":"Colors"},{"location":"appcompat-theme/#typography","text":"AppCompat does not provide any semantic text appearances (such as headline6, body1, etc), and instead relies on text appearances for specific widgets or use cases. As such, the only thing we read from an AppCompat theme is the default app:fontFamily or android:fontFamily . For example: <style name= \"Theme.MyApp\" parent= \"Theme.AppCompat\" > <item name= \"fontFamily\" > @font/my_font </item> </style> Compose does not currently support downloadable fonts, so any font referenced from the theme should from your resources. See here for more information.","title":"Typography"},{"location":"appcompat-theme/#shape","text":"AppCompat has no concept of shape theming, therefore we use the default value from MaterialTheme.shapes . If you wish to provide custom values, use the shapes parameter on AppCompatTheme .","title":"Shape"},{"location":"appcompat-theme/#limitations","text":"There are some known limitations with the implementation at the moment: This relies on your Activity / Context theme extending one of the Theme.AppCompat themes. Variable fonts are not supported in Compose yet, meaning that the value of android:fontVariationSettings are currently ignored. You can modify the resulting MaterialTheme in Compose as required, but this only works in Compose. Any changes you make will not be reflected in the Activity theme.","title":"Limitations"},{"location":"appcompat-theme/#usage","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-appcompat-theme:<version>\" }","title":"Usage"},{"location":"appcompat-theme/#library-snapshots","text":"Snapshots of the current development version of this library are available, which track the latest commit. See here for more information on how to use them.","title":"Library Snapshots"},{"location":"appcompat-theme/#contributions","text":"Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though.","title":"Contributions"},{"location":"appcompat-theme/#license","text":"Copyright 2020 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"contributing/","text":"How to Contribute \u00b6 We'd love to accept your patches and contributions to this project. There are just a few small guidelines you need to follow. New Features/Libraries \u00b6 Before contributing large new features and/or libraries please start a discussion with us first via GitHub Issues and check that we can support it. We are unable to support all new features, even though we wish we could! If we are unable to support adding your feature, we always encourage you to open source it in your own repository to help the Compose community grow. Contributor License Agreement \u00b6 Contributions to this project must be accompanied by a Contributor License Agreement. You (or your employer) retain the copyright to your contribution, this simply gives us permission to use and redistribute your contributions as part of the project. Head over to https://cla.developers.google.com/ to see your current agreements on file or to sign a new one. You generally only need to submit a CLA once, so if you've already submitted one (even if it was for a different project), you probably don't need to do it again. Code Reviews \u00b6 All submissions, including submissions by project members, require review. We use GitHub pull requests for this purpose. Consult GitHub Help for more information on using pull requests.","title":"Contributing"},{"location":"contributing/#how-to-contribute","text":"We'd love to accept your patches and contributions to this project. There are just a few small guidelines you need to follow.","title":"How to Contribute"},{"location":"contributing/#new-featureslibraries","text":"Before contributing large new features and/or libraries please start a discussion with us first via GitHub Issues and check that we can support it. We are unable to support all new features, even though we wish we could! If we are unable to support adding your feature, we always encourage you to open source it in your own repository to help the Compose community grow.","title":"New Features/Libraries"},{"location":"contributing/#contributor-license-agreement","text":"Contributions to this project must be accompanied by a Contributor License Agreement. You (or your employer) retain the copyright to your contribution, this simply gives us permission to use and redistribute your contributions as part of the project. Head over to https://cla.developers.google.com/ to see your current agreements on file or to sign a new one. You generally only need to submit a CLA once, so if you've already submitted one (even if it was for a different project), you probably don't need to do it again.","title":"Contributor License Agreement"},{"location":"contributing/#code-reviews","text":"All submissions, including submissions by project members, require review. We use GitHub pull requests for this purpose. Consult GitHub Help for more information on using pull requests.","title":"Code Reviews"},{"location":"drawablepainter/","text":"Drawable Painter \u00b6 A library which provides a way to use Android drawables as Jetpack Compose Painters . This library attempts to support most Drawable configuration, as well as Animatable drawables, such as AnimatedVectorDrawable . Usage \u00b6 @Composable fun DrawDrawable () { val drawable = AppCompatResources . getDrawable ( LocalContext . current , R . drawable . rectangle ) Image ( painter = rememberDrawablePainter ( drawable = drawable ), contentDescription = \"content description\" , ) } Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-drawablepainter:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Guide"},{"location":"drawablepainter/#drawable-painter","text":"A library which provides a way to use Android drawables as Jetpack Compose Painters . This library attempts to support most Drawable configuration, as well as Animatable drawables, such as AnimatedVectorDrawable .","title":"Drawable Painter"},{"location":"drawablepainter/#usage","text":"@Composable fun DrawDrawable () { val drawable = AppCompatResources . getDrawable ( LocalContext . current , R . drawable . rectangle ) Image ( painter = rememberDrawablePainter ( drawable = drawable ), contentDescription = \"content description\" , ) }","title":"Usage"},{"location":"drawablepainter/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-drawablepainter:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Download"},{"location":"flowlayout/","text":"Jetpack Compose Flow Layouts \u00b6 Flow layouts adapted from the versions which were available in Jetpack Compose until they were removed. Unlike the standard Row and Column composables, these layout children across multiple rows/columns if they exceed the available space. Usage \u00b6 FlowRow { // row contents } FlowColumn { // column contents } For examples, refer to the samples . Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-flowlayout:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Guide"},{"location":"flowlayout/#jetpack-compose-flow-layouts","text":"Flow layouts adapted from the versions which were available in Jetpack Compose until they were removed. Unlike the standard Row and Column composables, these layout children across multiple rows/columns if they exceed the available space.","title":"Jetpack Compose Flow Layouts"},{"location":"flowlayout/#usage","text":"FlowRow { // row contents } FlowColumn { // column contents } For examples, refer to the samples .","title":"Usage"},{"location":"flowlayout/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-flowlayout:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Download"},{"location":"insets/","text":"Insets for Jetpack Compose \u00b6 Warning This library is deprecated, with official insets support in androidx.compose.foundation. The migration guide and original documentation is below. Migration \u00b6 The official androidx.compose.foundation insets support is very similar to accompanist/insets, with a few changes. androidx.compose.foundation also does not disable window decor fitting, so you still need to call WindowCompat.setDecorFitsSystemWindows(window, false) from your Activity. You also still need to set the system bar backgrounds to be transparent, which can be done with our System UI Controller library. If you are using insets for IME support, you also still need to ensure that the activity's windowSoftInputMode is set to adjustResize : <activity android:name= \".MyActivity\" android:windowSoftInputMode= \"adjustResize\" > </activity> Migration steps: \u00b6 Remove ProvideWindowInsets (there is no equivalent in androidx.compose.foundation ) Remove ViewWindowInsetObserver (there is no equivalent in androidx.compose.foundation ) Replace padding modifiers with androidx.compose.foundation equivalents. If using additionalPadding or only applying the insets to certain sides, use the corresponding WindowInsets.add and WindowInsets.only extensions. Replace rememberInsetsPaddingValues with the equivalent WindowInsets.asPaddingValues . Replace direct calculations from LocalWindowInsets.current with calculations on WindowInsets . Continue using the non-deprecated insets-ui for now. For reference, consult the Migration table below. Inset consumption \u00b6 The biggest behavioral change between accompanist/insets and androidx.compose.foundation is in the consumption behavior of padding modifiers. In accompanist/insets , the padding modifiers always padded the full size of the specified inset types, which led to some unintuitive duplicate padding when nesting modifiers. For example, let\u2019s look at what happens when we have nested boxes, where the outer one has Modifier.systemBarsPadding() applied, and the inner has Modifier.imePadding(): Box ( Modifier . systemBarsPadding ()) { Box ( Modifier . imePadding ()) { // content } } Let\u2019s assume that the bottom system bar padding is 30dp , to account for the navigation bar padding, and let\u2019s assume that when the IME is visible, the height of the IME is 150dp . When the IME is closed, the outer box will apply the bottom 30dp as padding, and the inner box will apply zero additional padding, since the IME isn\u2019t visible. When the IME opens, the outer box will continue to apply the bottom 30dp as the system bar padding, and the inner box will now apply 150dp bottom padding, since that is the full height of the IME. This results in a total padding of 180dp applied to the content, which double pads the bottom navigation bar padding. The solutions to this issue were using derivedWindowInsetsTypeOf , built-in derived types like Modifier.navigationBarsWithImePadding() , or performing calculations manually to apply the remaining padding. In androidx.compose.foundation , when the IME is open, the outer box still apply the bottom 30dp , but the inner box will only apply the remaining 120dp needed to have the content be padded a total of 150dp to match the height of the IME. This behavior can be influenced further in androidx.compose.foundation with Modifier.consumedWindowInsets() As a result, the equivalent of Modifier.navigationBarsWithImePadding() is simply Modifier.navigationBarsPadding().imePadding() . Migration table: \u00b6 accompanist/insets androidx.compose.foundation ProvideWindowInsets (remove) Modifier.systemBarsPadding() Modifier.systemBarsPadding() Modifier.systemBarsPadding(bottom = false) Modifier.windowInsetsPadding(WindowInsets.systemBars.only(WindowInsetsSides.Horizontal + WindowInsetsSides.Top)) Modifier.statusBarsPadding() Modifier.statusBarsPadding() Modifier.navigationBarsPadding() Modifier.navigationBarsPadding() Modifier.imePadding() Modifier.imePadding() Modifier.cutoutPadding() Modifier.displayCutoutPadding() Modifier.navigationBarsWithImePadding() Modifier.navigationBarsPadding().imePadding() Modifier.statusBarsHeight() Modifier.windowInsetsTopHeight(WindowInsets.statusBars) Modifier.navigationBarsHeight() Modifier.windowInsetsBottomHeight(WindowInsets.navigationBars) Modifier.navigationBarsWidth() Modifier.windowInsetsStartWidth(WindowInsets.navigationBars) / Modifier.windowInsetsEndWidth(WindowInsets.navigationBars) rememberInsetsPaddingValues(insets = LocalWindowInsets.current.statusBars, applyStart = true, applyTop = true, applyEnd = true) WindowInsets.statusBars.only(WindowInsetsSides.Horizontal + WindowInsetsSides.Top).asPaddingValues() derivedWindowInsetsTypeOf WindowInsets.union(windowInsets: WindowInsets) LocalWindowInsets.current.navigationBars WindowInsets.navigationBars LocalWindowInsets.current.statusBars WindowInsets.statusBars LocalWindowInsets.current.ime WindowInsets.ime LocalWindowInsets.current.systemGestures WindowInsets.systemGestures LocalWindowInsets.current.systemBars WindowInsets.systemBars LocalWindowInsets.current.displayCutout WindowInsets.displayCutout LocalWindowInsets.current.ime.bottom WindowInsets.ime.getBottom(LocalDensity.current) WindowInsets.Type.isVisible WindowInsets.isImeVisible , etc. WindowInsets.Type.animationInProgress Bug: 217770337 WindowInsets.Type.animationFraction Bug: 217770337 WindowInsets.Type.layoutInsets Bug: 217770337 WindowInsets.Type.animatedInsets Bug: 217770337 rememberImeNestedScrollConnection() Modifier.imeNestedScroll() Original docs \u00b6 Insets for Jetpack Compose takes a lot of the ideas which drove Insetter for views, and applies them for use in composables. Usage \u00b6 To setup Insets in your composables, you need to call the ProvideWindowInsets function and wrap your content. This would typically be done near the top level of your composable hierarchy: setContent { MaterialTheme { ProvideWindowInsets { // your content } } } Note This library does not disable window decor fitting. For your view hierarchy to able to receive insets, you need to make sure to call: WindowCompat.setDecorFitsSystemWindows(window, false) from your Activity. You also need to set the system bar backgrounds to be transparent, which can be done with our System UI Controller library. ProvideWindowInsets allows the library to set an OnApplyWindowInsetsListener on your content's host view. That listener is used to update the value of a composition local bundled in this library: LocalWindowInsets . LocalWindowInsets holds an instance of WindowInsets which contains the value of various WindowInsets types . You can use the values manually like so: @Composable fun ImeAvoidingBox () { val insets = LocalWindowInsets . current val imeBottom = with ( LocalDensity . current ) { insets . ime . bottom . toDp () } Box ( Modifier . padding ( bottom = imeBottom )) } ...but we also provide some easy-to-use Modifier s. Modifiers \u00b6 We provide two types of modifiers for easy handling of insets: padding and size. Padding modifiers \u00b6 The padding modifiers allow you to apply padding to a composable which matches a specific type of inset. Currently we provide: Modifier.statusBarsPadding() Modifier.navigationBarsPadding() Modifier.systemBarsPadding() Modifier.imePadding() Modifier.navigationBarsWithImePadding() Modifier.cutoutPadding() These are commonly used to move composables out from under the system bars. The common example would be a FloatingActionButton : FloatingActionButton ( onClick = { /* TODO */ }, modifier = Modifier . align ( Alignment . BottomEnd ) . padding ( 16. dp ) // normal 16dp of padding for FABs . navigationBarsPadding () // Move it out from under the nav bar ) { Icon ( imageVector = Icons . Default . Add , contentDescription = null ) } Size modifiers \u00b6 The size modifiers allow you to match the size of a composable to a specific type of inset. Currently we provide: Modifier.statusBarsHeight() Modifier.navigationBarsHeight() Modifier.navigationBarsWidth() These are commonly used to allow composables behind the system bars, to provide background protection, or similar: Spacer ( Modifier . background ( Color . Black . copy ( alpha = 0.7f )) . statusBarsHeight () // Match the height of the status bar . fillMaxWidth () ) PaddingValues \u00b6 Compose also provides the concept of PaddingValues , a data class which contains the padding values to be applied on all dimensions (similar to a rect). This is commonly used with container composables, such as LazyColumn , to set the content padding. You may want to use inset values for content padding, so this library provides the rememberInsetsPaddingValues() extension function to convert between Insets and PaddingValues . Here's an example of using the system bars insets: LazyColumn ( contentPadding = rememberInsetsPaddingValues ( insets = LocalWindowInsets . current . systemBars , applyTop = true , applyBottom = true , ) ) { // content } For a more complex example, see the EdgeToEdgeLazyColumn example: Inset-aware layouts ( insets-ui ) \u00b6 Unfortunately, most of Compose Material's layouts do not support the use of content padding, which means that the following code probably doesn't produce the effect you want: // \ud83d\ude25 This likely doesn't do what you want TopAppBar ( // content modifier = Modifier . statusBarsPadding () ) To workaround this, we provide the insets-ui companion library which contains versions of commonly used layouts, with the addition of a contentPadding parameter. The example below is using our TopAppBar layout, providing the status bar insets to use as content padding: import com.google.accompanist.insets.ui.TopAppBar TopAppBar ( contentPadding = rememberInsetsPaddingValues ( insets = LocalWindowInsets . current . statusBars , applyStart = true , applyTop = true , applyEnd = true , ) ) { // content } The library also provides a modified copy of Compose Material's Scaffold which better supports edge-to-edge layouts, by drawing the top and bottom bars over the content. Scaffold ( topBar = { // We use TopAppBar from accompanist-insets-ui which allows us to provide // content padding matching the system bars insets. TopAppBar ( title = { Text ( stringResource ( R . string . insets_title_list )) }, backgroundColor = MaterialTheme . colors . surface . copy ( alpha = 0.9f ), contentPadding = rememberInsetsPaddingValues ( LocalWindowInsets . current . statusBars , applyBottom = false , ), ) }, bottomBar = { // We add a spacer as a bottom bar, which is the same height as // the navigation bar Spacer ( Modifier . navigationBarsHeight (). fillMaxWidth ()) }, ) { contentPadding -> // We apply the contentPadding passed to us from the Scaffold Box ( Modifier . padding ( contentPadding )) { // content } } See the API docs for a list of the other layouts provided in the library. Animated Insets support \u00b6 Info The library now has experimental support for WindowInsetsAnimations , allowing your content is react to inset animations, such as the on screen-keyboard (IME) being animated on/off screen. The imePadding() and navigationBarsWithImePadding() modifiers are available especially for this use-case. This functionality works wherever WindowInsetsAnimationCompat works, which at the time or writing is on devices running API 21+. To enable animated insets support, you need need to new ProvideWindowInsets overload, and set windowInsetsAnimationsEnabled = true . Usage ProvideWindowInsets ( windowInsetsAnimationsEnabled = true ) { // content } You can then use the new navigationBarsWithImePadding() modifier like so: OutlinedTextField ( // other params, modifier = Modifier . navigationBarsWithImePadding () ) See the ImeAnimationSample for a working example. IME animations \u00b6 If you're using the animation insets support for IME/keyboard animations, you also need to ensure that the activity's windowSoftInputMode is set to adjustResize : <activity android:name= \".MyActivity\" android:windowSoftInputMode= \"adjustResize\" > </activity> The default value of windowSoftInputMode should work, but Compose does not currently set the flags necessary (see here ). \ud83d\udea7 Experimental \u00b6 The features below are experimental, and require developers to opt-in . Controlling the IME (on-screen keyboard) \u00b6 Info This library also has support for controlling the IME from scroll gestures, allowing your scrollable components to pull/push the IME on/off screen. This is achieved through the built-in NestedScrollConnection implementation returned by rememberImeNestedScrollConnection() . This functionality only works when running on devices with API 30+. Usage // Here we're using a scrollable Column, but it also works with LazyColumn, etc. Column ( // We use the nestedScroll modifier, passing in the // the connection from rememberImeNestedScrollConnection() modifier = Modifier . nestedScroll ( connection = rememberImeNestedScrollConnection ()) . verticalScroll ( state = rememberScrollState ()) ) { // list content } See the ImeAnimationSample for a working example. Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-insets:<version>\" // If using insets-ui implementation \"com.google.accompanist:accompanist-insets-ui:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit. Something not working? \u00b6 If you find that something isn't working correctly, here's a checklist to try: Check that you've called WindowCompat.setDecorFitsSystemWindows(window, false) in your Activity. Unless you do that, the window decor will consume the insets, and they will not be dispatched to your content. If it's something related to the keyboard, check that the Activity's windowSoftInputMode is set to adjustResize . Without that, IME visibility changes will not be sent as inset changes. Similarly, if you're setting android:windowFullscreen to true (or using a .Fullscreen theme), be aware that adjustResize will not work. Please see the documentation for an alternative. If you're using ProvideWindowInsets (or ViewWindowInsetObserver ) in multiple layers of your view hierarchy (i.e. in the activity, and in a fragment), you need to turn off consuming of insets. By default ProvideWindowInsets and ViewWindowInsetObserver will completely consume any insets passed to it. In the previous example, this means that the activity content will get the insets, but the fragment won't. To disable consuming, pass consumeWindowInsets = false to ProvideWindowInsets or ViewWindowInsetObserver.start() .","title":"Guide"},{"location":"insets/#insets-for-jetpack-compose","text":"Warning This library is deprecated, with official insets support in androidx.compose.foundation. The migration guide and original documentation is below.","title":"Insets for Jetpack Compose"},{"location":"insets/#migration","text":"The official androidx.compose.foundation insets support is very similar to accompanist/insets, with a few changes. androidx.compose.foundation also does not disable window decor fitting, so you still need to call WindowCompat.setDecorFitsSystemWindows(window, false) from your Activity. You also still need to set the system bar backgrounds to be transparent, which can be done with our System UI Controller library. If you are using insets for IME support, you also still need to ensure that the activity's windowSoftInputMode is set to adjustResize : <activity android:name= \".MyActivity\" android:windowSoftInputMode= \"adjustResize\" > </activity>","title":"Migration"},{"location":"insets/#migration-steps","text":"Remove ProvideWindowInsets (there is no equivalent in androidx.compose.foundation ) Remove ViewWindowInsetObserver (there is no equivalent in androidx.compose.foundation ) Replace padding modifiers with androidx.compose.foundation equivalents. If using additionalPadding or only applying the insets to certain sides, use the corresponding WindowInsets.add and WindowInsets.only extensions. Replace rememberInsetsPaddingValues with the equivalent WindowInsets.asPaddingValues . Replace direct calculations from LocalWindowInsets.current with calculations on WindowInsets . Continue using the non-deprecated insets-ui for now. For reference, consult the Migration table below.","title":"Migration steps:"},{"location":"insets/#inset-consumption","text":"The biggest behavioral change between accompanist/insets and androidx.compose.foundation is in the consumption behavior of padding modifiers. In accompanist/insets , the padding modifiers always padded the full size of the specified inset types, which led to some unintuitive duplicate padding when nesting modifiers. For example, let\u2019s look at what happens when we have nested boxes, where the outer one has Modifier.systemBarsPadding() applied, and the inner has Modifier.imePadding(): Box ( Modifier . systemBarsPadding ()) { Box ( Modifier . imePadding ()) { // content } } Let\u2019s assume that the bottom system bar padding is 30dp , to account for the navigation bar padding, and let\u2019s assume that when the IME is visible, the height of the IME is 150dp . When the IME is closed, the outer box will apply the bottom 30dp as padding, and the inner box will apply zero additional padding, since the IME isn\u2019t visible. When the IME opens, the outer box will continue to apply the bottom 30dp as the system bar padding, and the inner box will now apply 150dp bottom padding, since that is the full height of the IME. This results in a total padding of 180dp applied to the content, which double pads the bottom navigation bar padding. The solutions to this issue were using derivedWindowInsetsTypeOf , built-in derived types like Modifier.navigationBarsWithImePadding() , or performing calculations manually to apply the remaining padding. In androidx.compose.foundation , when the IME is open, the outer box still apply the bottom 30dp , but the inner box will only apply the remaining 120dp needed to have the content be padded a total of 150dp to match the height of the IME. This behavior can be influenced further in androidx.compose.foundation with Modifier.consumedWindowInsets() As a result, the equivalent of Modifier.navigationBarsWithImePadding() is simply Modifier.navigationBarsPadding().imePadding() .","title":"Inset consumption"},{"location":"insets/#migration-table","text":"accompanist/insets androidx.compose.foundation ProvideWindowInsets (remove) Modifier.systemBarsPadding() Modifier.systemBarsPadding() Modifier.systemBarsPadding(bottom = false) Modifier.windowInsetsPadding(WindowInsets.systemBars.only(WindowInsetsSides.Horizontal + WindowInsetsSides.Top)) Modifier.statusBarsPadding() Modifier.statusBarsPadding() Modifier.navigationBarsPadding() Modifier.navigationBarsPadding() Modifier.imePadding() Modifier.imePadding() Modifier.cutoutPadding() Modifier.displayCutoutPadding() Modifier.navigationBarsWithImePadding() Modifier.navigationBarsPadding().imePadding() Modifier.statusBarsHeight() Modifier.windowInsetsTopHeight(WindowInsets.statusBars) Modifier.navigationBarsHeight() Modifier.windowInsetsBottomHeight(WindowInsets.navigationBars) Modifier.navigationBarsWidth() Modifier.windowInsetsStartWidth(WindowInsets.navigationBars) / Modifier.windowInsetsEndWidth(WindowInsets.navigationBars) rememberInsetsPaddingValues(insets = LocalWindowInsets.current.statusBars, applyStart = true, applyTop = true, applyEnd = true) WindowInsets.statusBars.only(WindowInsetsSides.Horizontal + WindowInsetsSides.Top).asPaddingValues() derivedWindowInsetsTypeOf WindowInsets.union(windowInsets: WindowInsets) LocalWindowInsets.current.navigationBars WindowInsets.navigationBars LocalWindowInsets.current.statusBars WindowInsets.statusBars LocalWindowInsets.current.ime WindowInsets.ime LocalWindowInsets.current.systemGestures WindowInsets.systemGestures LocalWindowInsets.current.systemBars WindowInsets.systemBars LocalWindowInsets.current.displayCutout WindowInsets.displayCutout LocalWindowInsets.current.ime.bottom WindowInsets.ime.getBottom(LocalDensity.current) WindowInsets.Type.isVisible WindowInsets.isImeVisible , etc. WindowInsets.Type.animationInProgress Bug: 217770337 WindowInsets.Type.animationFraction Bug: 217770337 WindowInsets.Type.layoutInsets Bug: 217770337 WindowInsets.Type.animatedInsets Bug: 217770337 rememberImeNestedScrollConnection() Modifier.imeNestedScroll()","title":"Migration table:"},{"location":"insets/#original-docs","text":"Insets for Jetpack Compose takes a lot of the ideas which drove Insetter for views, and applies them for use in composables.","title":"Original docs"},{"location":"insets/#usage","text":"To setup Insets in your composables, you need to call the ProvideWindowInsets function and wrap your content. This would typically be done near the top level of your composable hierarchy: setContent { MaterialTheme { ProvideWindowInsets { // your content } } } Note This library does not disable window decor fitting. For your view hierarchy to able to receive insets, you need to make sure to call: WindowCompat.setDecorFitsSystemWindows(window, false) from your Activity. You also need to set the system bar backgrounds to be transparent, which can be done with our System UI Controller library. ProvideWindowInsets allows the library to set an OnApplyWindowInsetsListener on your content's host view. That listener is used to update the value of a composition local bundled in this library: LocalWindowInsets . LocalWindowInsets holds an instance of WindowInsets which contains the value of various WindowInsets types . You can use the values manually like so: @Composable fun ImeAvoidingBox () { val insets = LocalWindowInsets . current val imeBottom = with ( LocalDensity . current ) { insets . ime . bottom . toDp () } Box ( Modifier . padding ( bottom = imeBottom )) } ...but we also provide some easy-to-use Modifier s.","title":"Usage"},{"location":"insets/#modifiers","text":"We provide two types of modifiers for easy handling of insets: padding and size.","title":"Modifiers"},{"location":"insets/#padding-modifiers","text":"The padding modifiers allow you to apply padding to a composable which matches a specific type of inset. Currently we provide: Modifier.statusBarsPadding() Modifier.navigationBarsPadding() Modifier.systemBarsPadding() Modifier.imePadding() Modifier.navigationBarsWithImePadding() Modifier.cutoutPadding() These are commonly used to move composables out from under the system bars. The common example would be a FloatingActionButton : FloatingActionButton ( onClick = { /* TODO */ }, modifier = Modifier . align ( Alignment . BottomEnd ) . padding ( 16. dp ) // normal 16dp of padding for FABs . navigationBarsPadding () // Move it out from under the nav bar ) { Icon ( imageVector = Icons . Default . Add , contentDescription = null ) }","title":"Padding modifiers"},{"location":"insets/#size-modifiers","text":"The size modifiers allow you to match the size of a composable to a specific type of inset. Currently we provide: Modifier.statusBarsHeight() Modifier.navigationBarsHeight() Modifier.navigationBarsWidth() These are commonly used to allow composables behind the system bars, to provide background protection, or similar: Spacer ( Modifier . background ( Color . Black . copy ( alpha = 0.7f )) . statusBarsHeight () // Match the height of the status bar . fillMaxWidth () )","title":"Size modifiers"},{"location":"insets/#paddingvalues","text":"Compose also provides the concept of PaddingValues , a data class which contains the padding values to be applied on all dimensions (similar to a rect). This is commonly used with container composables, such as LazyColumn , to set the content padding. You may want to use inset values for content padding, so this library provides the rememberInsetsPaddingValues() extension function to convert between Insets and PaddingValues . Here's an example of using the system bars insets: LazyColumn ( contentPadding = rememberInsetsPaddingValues ( insets = LocalWindowInsets . current . systemBars , applyTop = true , applyBottom = true , ) ) { // content } For a more complex example, see the EdgeToEdgeLazyColumn example:","title":"PaddingValues"},{"location":"insets/#inset-aware-layouts-insets-ui","text":"Unfortunately, most of Compose Material's layouts do not support the use of content padding, which means that the following code probably doesn't produce the effect you want: // \ud83d\ude25 This likely doesn't do what you want TopAppBar ( // content modifier = Modifier . statusBarsPadding () ) To workaround this, we provide the insets-ui companion library which contains versions of commonly used layouts, with the addition of a contentPadding parameter. The example below is using our TopAppBar layout, providing the status bar insets to use as content padding: import com.google.accompanist.insets.ui.TopAppBar TopAppBar ( contentPadding = rememberInsetsPaddingValues ( insets = LocalWindowInsets . current . statusBars , applyStart = true , applyTop = true , applyEnd = true , ) ) { // content } The library also provides a modified copy of Compose Material's Scaffold which better supports edge-to-edge layouts, by drawing the top and bottom bars over the content. Scaffold ( topBar = { // We use TopAppBar from accompanist-insets-ui which allows us to provide // content padding matching the system bars insets. TopAppBar ( title = { Text ( stringResource ( R . string . insets_title_list )) }, backgroundColor = MaterialTheme . colors . surface . copy ( alpha = 0.9f ), contentPadding = rememberInsetsPaddingValues ( LocalWindowInsets . current . statusBars , applyBottom = false , ), ) }, bottomBar = { // We add a spacer as a bottom bar, which is the same height as // the navigation bar Spacer ( Modifier . navigationBarsHeight (). fillMaxWidth ()) }, ) { contentPadding -> // We apply the contentPadding passed to us from the Scaffold Box ( Modifier . padding ( contentPadding )) { // content } } See the API docs for a list of the other layouts provided in the library.","title":"Inset-aware layouts (insets-ui)"},{"location":"insets/#animated-insets-support","text":"Info The library now has experimental support for WindowInsetsAnimations , allowing your content is react to inset animations, such as the on screen-keyboard (IME) being animated on/off screen. The imePadding() and navigationBarsWithImePadding() modifiers are available especially for this use-case. This functionality works wherever WindowInsetsAnimationCompat works, which at the time or writing is on devices running API 21+. To enable animated insets support, you need need to new ProvideWindowInsets overload, and set windowInsetsAnimationsEnabled = true . Usage ProvideWindowInsets ( windowInsetsAnimationsEnabled = true ) { // content } You can then use the new navigationBarsWithImePadding() modifier like so: OutlinedTextField ( // other params, modifier = Modifier . navigationBarsWithImePadding () ) See the ImeAnimationSample for a working example.","title":"Animated Insets support"},{"location":"insets/#ime-animations","text":"If you're using the animation insets support for IME/keyboard animations, you also need to ensure that the activity's windowSoftInputMode is set to adjustResize : <activity android:name= \".MyActivity\" android:windowSoftInputMode= \"adjustResize\" > </activity> The default value of windowSoftInputMode should work, but Compose does not currently set the flags necessary (see here ).","title":"IME animations"},{"location":"insets/#experimental","text":"The features below are experimental, and require developers to opt-in .","title":"\ud83d\udea7 Experimental"},{"location":"insets/#controlling-the-ime-on-screen-keyboard","text":"Info This library also has support for controlling the IME from scroll gestures, allowing your scrollable components to pull/push the IME on/off screen. This is achieved through the built-in NestedScrollConnection implementation returned by rememberImeNestedScrollConnection() . This functionality only works when running on devices with API 30+. Usage // Here we're using a scrollable Column, but it also works with LazyColumn, etc. Column ( // We use the nestedScroll modifier, passing in the // the connection from rememberImeNestedScrollConnection() modifier = Modifier . nestedScroll ( connection = rememberImeNestedScrollConnection ()) . verticalScroll ( state = rememberScrollState ()) ) { // list content } See the ImeAnimationSample for a working example.","title":"Controlling the IME (on-screen keyboard)"},{"location":"insets/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-insets:<version>\" // If using insets-ui implementation \"com.google.accompanist:accompanist-insets-ui:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Download"},{"location":"insets/#something-not-working","text":"If you find that something isn't working correctly, here's a checklist to try: Check that you've called WindowCompat.setDecorFitsSystemWindows(window, false) in your Activity. Unless you do that, the window decor will consume the insets, and they will not be dispatched to your content. If it's something related to the keyboard, check that the Activity's windowSoftInputMode is set to adjustResize . Without that, IME visibility changes will not be sent as inset changes. Similarly, if you're setting android:windowFullscreen to true (or using a .Fullscreen theme), be aware that adjustResize will not work. Please see the documentation for an alternative. If you're using ProvideWindowInsets (or ViewWindowInsetObserver ) in multiple layers of your view hierarchy (i.e. in the activity, and in a fragment), you need to turn off consuming of insets. By default ProvideWindowInsets and ViewWindowInsetObserver will completely consume any insets passed to it. In the previous example, this means that the activity content will get the insets, but the fragment won't. To disable consuming, pass consumeWindowInsets = false to ProvideWindowInsets or ViewWindowInsetObserver.start() .","title":"Something not working?"},{"location":"migration/","text":"Migration from dev.chrisbanes.accompanist \u00b6 In March 2021, the Accompanist project moved from github.com/chrisbanes/accompanist to github.com/google/accompanist . At the same time we migrated the libraries over to a new package name and Maven group ID. As a summary: All code was refactored from the dev.chrisbanes.accompanist root package to com.google.accompanist package. The Maven group ID was changed from dev.chrisbanes.accompanist to com.google.accompanist . Semi-automatic migration... \u00b6 The following methods below are available for your information only, but may help if you need to migrate from the old package name. Warning Use these at your own risk, but they have worked on multiple projects from my testing. It's a good idea to make sure that you've made a backup or committed any changes before running these. Android Studio / IntelliJ \u00b6 You can use the Replace in Path pane (\u21e7\u2318R on Mac) in Android Studio to do a project-wide search and replace. Find query: dev.chrisbanes.accompanist Replace string: com.google.accompanist Optional: Set the file mask to *.kt so that only Kotlin files are searched. Repeat for *.gradle . Similar can be achieved in Visual Studio Code . Other IDEs / text editors are available. YOLO commands \u00b6 These commands while automatically replace any imports and Gradle dependencies for the project in the current directory. MacOS \u00b6 find . -type f \\( -name '*.kt' -or -name '*.gradle*' \\) \\ -exec sed -i '' 's/dev\\.chrisbanes\\.accompanist/com\\.google\\.accompanist/' {} \\; Linux \u00b6 find . -type f \\( -name '*.kt' -or -name '*.gradle*' \\) \\ -exec sed -i 's/dev\\.chrisbanes\\.accompanist/com\\.google\\.accompanist/' {} \\;","title":"Migration from dev.chrisbanes.accompanist"},{"location":"migration/#migration-from-devchrisbanesaccompanist","text":"In March 2021, the Accompanist project moved from github.com/chrisbanes/accompanist to github.com/google/accompanist . At the same time we migrated the libraries over to a new package name and Maven group ID. As a summary: All code was refactored from the dev.chrisbanes.accompanist root package to com.google.accompanist package. The Maven group ID was changed from dev.chrisbanes.accompanist to com.google.accompanist .","title":"Migration from dev.chrisbanes.accompanist"},{"location":"migration/#semi-automatic-migration","text":"The following methods below are available for your information only, but may help if you need to migrate from the old package name. Warning Use these at your own risk, but they have worked on multiple projects from my testing. It's a good idea to make sure that you've made a backup or committed any changes before running these.","title":"Semi-automatic migration..."},{"location":"migration/#android-studio-intellij","text":"You can use the Replace in Path pane (\u21e7\u2318R on Mac) in Android Studio to do a project-wide search and replace. Find query: dev.chrisbanes.accompanist Replace string: com.google.accompanist Optional: Set the file mask to *.kt so that only Kotlin files are searched. Repeat for *.gradle . Similar can be achieved in Visual Studio Code . Other IDEs / text editors are available.","title":"Android Studio / IntelliJ"},{"location":"migration/#yolo-commands","text":"These commands while automatically replace any imports and Gradle dependencies for the project in the current directory.","title":"YOLO commands"},{"location":"migration/#macos","text":"find . -type f \\( -name '*.kt' -or -name '*.gradle*' \\) \\ -exec sed -i '' 's/dev\\.chrisbanes\\.accompanist/com\\.google\\.accompanist/' {} \\;","title":"MacOS"},{"location":"migration/#linux","text":"find . -type f \\( -name '*.kt' -or -name '*.gradle*' \\) \\ -exec sed -i 's/dev\\.chrisbanes\\.accompanist/com\\.google\\.accompanist/' {} \\;","title":"Linux"},{"location":"navigation-animation/","text":"Jetpack Navigation Compose Animation \u00b6 A library which provides Compose Animation support for Jetpack Navigation Compose . Warning The navigation APIs are currently experimental and they could change at any time. All of the APIs are marked with the @ExperimentalAnimationApi annotation. Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-navigation-animation:<version>\" } Follow the steps below to either add Jetpack Navigation Compose to your app, or to migrate an existing Jetpack Navigation Compose implementation. Usage \u00b6 The AnimatedNavHost composable offers a way to add custom transitions to composables in Navigation Compose via parameters that can be attached to either an individual composable destination, a navigation element, or to the AnimatedNavHost itself. Each lambda has an AnimatedContentScope<NavBackStackEntry> receiver scope that allows you to use special transitions (such as slideIntoContainer and slideOutOfContainer ) and gives you access to the initialState and targetState properties that let you customize what transitions are run based on what screen you are transitioning from (the initialState ) and transitioning to (the targetState ). enterTransition controls what EnterTransition is run when the targetState NavBackStackEntry is appearing on the screen. exitTransition controls what ExitTransition is run when the initialState NavBackStackEntry is disappearing from the screen. popEnterTransition defaults to enterTransition , but can be overridden to provide a separate EnterTransition when the targetState NavBackStackEntry is appearing on the screen due to a pop operation (i.e., popBackStack() ). popExitTransition defaults to exitTransition , but can be overridden to provide a separate ExitTransition when the initialState NavBackStackEntry is disappearing from the screen due to a pop operation (i.e., popBackStack() ). For each transition, if a composable destination returns null , the parent navigation element's transition will be used, thus allowing you to set a global set of transitions at the navigation graph level that will apply to every composable in that graph. This continues up the hierarchy until you reach the root AnimatedNavHost , which controls the global transitions for all destinations and nested graphs that do not specify one. Note: this means that if a destination wants to instantly jump cut between destinations, it should return EnterTransition.None or ExitTransition.None to signify that no transition should be run, rather than return null . @Composable private fun ExperimentalAnimationNav () { val navController = rememberAnimatedNavController () AnimatedNavHost ( navController , startDestination = \"Blue\" ) { composable ( \"Blue\" , enterTransition = { when ( initialState . destination . route ) { \"Red\" -> slideIntoContainer ( AnimatedContentScope . SlideDirection . Left , animationSpec = tween ( 700 )) else -> null } }, exitTransition = { when ( targetState . destination . route ) { \"Red\" -> slideOutOfContainer ( AnimatedContentScope . SlideDirection . Left , animationSpec = tween ( 700 )) else -> null } }, popEnterTransition = { when ( initialState . destination . route ) { \"Red\" -> slideIntoContainer ( AnimatedContentScope . SlideDirection . Right , animationSpec = tween ( 700 )) else -> null } }, popExitTransition = { when ( targetState . destination . route ) { \"Red\" -> slideOutOfContainer ( AnimatedContentScope . SlideDirection . Right , animationSpec = tween ( 700 )) else -> null } } ) { BlueScreen ( navController ) } composable ( \"Red\" , enterTransition = { when ( initialState . destination . route ) { \"Blue\" -> slideIntoContainer ( AnimatedContentScope . SlideDirection . Left , animationSpec = tween ( 700 )) else -> null } }, exitTransition = { when ( targetState . destination . route ) { \"Blue\" -> slideOutOfContainer ( AnimatedContentScope . SlideDirection . Left , animationSpec = tween ( 700 )) else -> null } }, popEnterTransition = { when ( initialState . destination . route ) { \"Blue\" -> slideIntoContainer ( AnimatedContentScope . SlideDirection . Right , animationSpec = tween ( 700 )) else -> null } }, popExitTransition = { when ( targetState . destination . route ) { \"Blue\" -> slideOutOfContainer ( AnimatedContentScope . SlideDirection . Right , animationSpec = tween ( 700 )) else -> null } } ) { RedScreen ( navController ) } } } For more examples, refer to the samples . Migration \u00b6 To migrate from using the Navigation Compose APIs do the following: Replace rememberNavController() with rememberAnimatedNavController() Replace NavHost with AnimatedNavHost Replace import androidx.navigation.compose.navigation with import com.google.accompanist.navigation.animation.navigation Replace import androidx.navigation.compose.composable with import com.google.accompanist.navigation.animation.composable Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit. For more details see Animations in Navigation Compose","title":"Guide"},{"location":"navigation-animation/#jetpack-navigation-compose-animation","text":"A library which provides Compose Animation support for Jetpack Navigation Compose . Warning The navigation APIs are currently experimental and they could change at any time. All of the APIs are marked with the @ExperimentalAnimationApi annotation.","title":"Jetpack Navigation Compose Animation"},{"location":"navigation-animation/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-navigation-animation:<version>\" } Follow the steps below to either add Jetpack Navigation Compose to your app, or to migrate an existing Jetpack Navigation Compose implementation.","title":"Download"},{"location":"navigation-animation/#usage","text":"The AnimatedNavHost composable offers a way to add custom transitions to composables in Navigation Compose via parameters that can be attached to either an individual composable destination, a navigation element, or to the AnimatedNavHost itself. Each lambda has an AnimatedContentScope<NavBackStackEntry> receiver scope that allows you to use special transitions (such as slideIntoContainer and slideOutOfContainer ) and gives you access to the initialState and targetState properties that let you customize what transitions are run based on what screen you are transitioning from (the initialState ) and transitioning to (the targetState ). enterTransition controls what EnterTransition is run when the targetState NavBackStackEntry is appearing on the screen. exitTransition controls what ExitTransition is run when the initialState NavBackStackEntry is disappearing from the screen. popEnterTransition defaults to enterTransition , but can be overridden to provide a separate EnterTransition when the targetState NavBackStackEntry is appearing on the screen due to a pop operation (i.e., popBackStack() ). popExitTransition defaults to exitTransition , but can be overridden to provide a separate ExitTransition when the initialState NavBackStackEntry is disappearing from the screen due to a pop operation (i.e., popBackStack() ). For each transition, if a composable destination returns null , the parent navigation element's transition will be used, thus allowing you to set a global set of transitions at the navigation graph level that will apply to every composable in that graph. This continues up the hierarchy until you reach the root AnimatedNavHost , which controls the global transitions for all destinations and nested graphs that do not specify one. Note: this means that if a destination wants to instantly jump cut between destinations, it should return EnterTransition.None or ExitTransition.None to signify that no transition should be run, rather than return null . @Composable private fun ExperimentalAnimationNav () { val navController = rememberAnimatedNavController () AnimatedNavHost ( navController , startDestination = \"Blue\" ) { composable ( \"Blue\" , enterTransition = { when ( initialState . destination . route ) { \"Red\" -> slideIntoContainer ( AnimatedContentScope . SlideDirection . Left , animationSpec = tween ( 700 )) else -> null } }, exitTransition = { when ( targetState . destination . route ) { \"Red\" -> slideOutOfContainer ( AnimatedContentScope . SlideDirection . Left , animationSpec = tween ( 700 )) else -> null } }, popEnterTransition = { when ( initialState . destination . route ) { \"Red\" -> slideIntoContainer ( AnimatedContentScope . SlideDirection . Right , animationSpec = tween ( 700 )) else -> null } }, popExitTransition = { when ( targetState . destination . route ) { \"Red\" -> slideOutOfContainer ( AnimatedContentScope . SlideDirection . Right , animationSpec = tween ( 700 )) else -> null } } ) { BlueScreen ( navController ) } composable ( \"Red\" , enterTransition = { when ( initialState . destination . route ) { \"Blue\" -> slideIntoContainer ( AnimatedContentScope . SlideDirection . Left , animationSpec = tween ( 700 )) else -> null } }, exitTransition = { when ( targetState . destination . route ) { \"Blue\" -> slideOutOfContainer ( AnimatedContentScope . SlideDirection . Left , animationSpec = tween ( 700 )) else -> null } }, popEnterTransition = { when ( initialState . destination . route ) { \"Blue\" -> slideIntoContainer ( AnimatedContentScope . SlideDirection . Right , animationSpec = tween ( 700 )) else -> null } }, popExitTransition = { when ( targetState . destination . route ) { \"Blue\" -> slideOutOfContainer ( AnimatedContentScope . SlideDirection . Right , animationSpec = tween ( 700 )) else -> null } } ) { RedScreen ( navController ) } } } For more examples, refer to the samples .","title":"Usage"},{"location":"navigation-animation/#migration","text":"To migrate from using the Navigation Compose APIs do the following: Replace rememberNavController() with rememberAnimatedNavController() Replace NavHost with AnimatedNavHost Replace import androidx.navigation.compose.navigation with import com.google.accompanist.navigation.animation.navigation Replace import androidx.navigation.compose.composable with import com.google.accompanist.navigation.animation.composable Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit. For more details see Animations in Navigation Compose","title":"Migration"},{"location":"navigation-material/","text":"Jetpack Navigation Compose Material \u00b6 A library which provides Compose Material support for Jetpack Navigation Compose . This features composable bottom sheet destinations. Warning The navigation APIs are currently experimental and they could change at any time. All of the APIs are marked with the @ExperimentalMaterialNavigationApi annotation. Usage \u00b6 Bottom Sheet Destinations \u00b6 Create a BottomSheetNavigator and add it to the NavController : @Composable fun MyApp () { val bottomSheetNavigator = rememberBottomSheetNavigator () val navController = rememberNavController ( bottomSheetNavigator ) } Wrap your NavHost in the ModalBottomSheetLayout composable that accepts a BottomSheetNavigator . @Composable fun MyApp () { val bottomSheetNavigator = rememberBottomSheetNavigator () val navController = rememberNavController ( bottomSheetNavigator ) ModalBottomSheetLayout ( bottomSheetNavigator ) { NavHost ( navController , \"home\" ) { // We'll define our graph here in a bit! } } } Register a bottom sheet destination @Composable fun MyApp () { val bottomSheetNavigator = rememberBottomSheetNavigator () val navController = rememberNavController ( bottomSheetNavigator ) ModalBottomSheetLayout ( bottomSheetNavigator ) { NavHost ( navController , \"home\" ) { composable ( route = \"home\" ) { ... } bottomSheet ( route = \"sheet\" ) { Text ( \"This is a cool bottom sheet!\" ) } } } } For more examples, refer to the samples . Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-navigation-material:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Guide"},{"location":"navigation-material/#jetpack-navigation-compose-material","text":"A library which provides Compose Material support for Jetpack Navigation Compose . This features composable bottom sheet destinations. Warning The navigation APIs are currently experimental and they could change at any time. All of the APIs are marked with the @ExperimentalMaterialNavigationApi annotation.","title":"Jetpack Navigation Compose Material"},{"location":"navigation-material/#usage","text":"","title":"Usage"},{"location":"navigation-material/#bottom-sheet-destinations","text":"Create a BottomSheetNavigator and add it to the NavController : @Composable fun MyApp () { val bottomSheetNavigator = rememberBottomSheetNavigator () val navController = rememberNavController ( bottomSheetNavigator ) } Wrap your NavHost in the ModalBottomSheetLayout composable that accepts a BottomSheetNavigator . @Composable fun MyApp () { val bottomSheetNavigator = rememberBottomSheetNavigator () val navController = rememberNavController ( bottomSheetNavigator ) ModalBottomSheetLayout ( bottomSheetNavigator ) { NavHost ( navController , \"home\" ) { // We'll define our graph here in a bit! } } } Register a bottom sheet destination @Composable fun MyApp () { val bottomSheetNavigator = rememberBottomSheetNavigator () val navController = rememberNavController ( bottomSheetNavigator ) ModalBottomSheetLayout ( bottomSheetNavigator ) { NavHost ( navController , \"home\" ) { composable ( route = \"home\" ) { ... } bottomSheet ( route = \"sheet\" ) { Text ( \"This is a cool bottom sheet!\" ) } } } } For more examples, refer to the samples .","title":"Bottom Sheet Destinations"},{"location":"navigation-material/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-navigation-material:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Download"},{"location":"pager/","text":"Pager layouts \u00b6 A library which provides paging layouts for Jetpack Compose. If you've used Android's ViewPager before, it has similar properties. Warning The pager layouts are currently experimental and the APIs could change at any time. All of the APIs are marked with the @ExperimentalPagerApi annotation. HorizontalPager \u00b6 HorizontalPager is a layout which lays out items in a horizontal row, and allows the user to horizontally swipe between pages. Your browser does not support the video tag. HorizontalPager demo The simplest usage looks like the following: // Display 10 items HorizontalPager ( count = 10 ) { page -> // Our page content Text ( text = \"Page: $ page \" , modifier = Modifier . fillMaxWidth () ) } If you want to jump to a specific page, you either call call pagerState.scrollToPage(index) or pagerState.animateScrollToPage(index) method in a CoroutineScope . val pagerState = rememberPagerState () HorizontalPager ( count = 10 , state = pagerState ) { page -> // ...page content } // Later, scroll to page 2 scope . launch { pagerState . scrollToPage ( 2 ) } VerticalPager \u00b6 VerticalPager is very similar to HorizontalPager but items are laid out vertically, and react to vertical swipes: Your browser does not support the video tag. VerticalPager demo // Display 10 items VerticalPager ( count = 10 ) { page -> // Our page content Text ( text = \"Page: $ page \" , modifier = Modifier . fillMaxWidth () ) } Lazy creation \u00b6 Pages in both HorizontalPager and VerticalPager are lazily composed and laid-out as required by the layout. As the user scrolls through pages, any pages which are no longer required are removed from the content. Under the covers, HorizontalPager use LazyRow , and VerticalPager uses LazyColumn . Content Padding \u00b6 HorizontalPager and VerticalPager both support the setting of content padding, which allows you to influence the maximum size and alignment of pages. You can see how different content padding values affect a HorizontalPager below: start = 64.dp Setting the start padding has the effect of aligning the pages towards the end. HorizontalPager ( count = 4 , contentPadding = PaddingValues ( start = 64. dp ), ) { page -> // page content } horizontal = 32.dp Setting both the start and end padding to the same value has the effect of centering the item horizontally. HorizontalPager ( count = 4 , contentPadding = PaddingValues ( horizontal = 32. dp ), ) { page -> // page content } end = 64.dp Setting the end padding has the effect of aligning the pages towards the start. HorizontalPager ( count = 4 , contentPadding = PaddingValues ( end = 64. dp ), ) { page -> // page content } Similar effects for VerticalPager can be achieved by setting the top and bottom values. The value 32.dp is only used here as an example, you can set each of the padding dimensions to whatever value you wish. Item scroll effects \u00b6 A common use-case is to apply effects to your pager items, using the scroll position to drive those effects. The HorizontalPagerTransitionSample demonstrates how this can be done: Your browser does not support the video tag. Item effects demo The scope provided to your pager content allows apps to easily reference the currentPage and currentPageOffset . The effects can then be calculated using those values. We provide the calculateCurrentOffsetForPage() extension functions to support calculation of the 'offset' for a given page: import com.google.accompanist.pager.calculateCurrentOffsetForPage HorizontalPager ( count = 4 ) { page -> Card ( Modifier . graphicsLayer { // Calculate the absolute offset for the current page from the // scroll position. We use the absolute value which allows us to mirror // any effects for both directions val pageOffset = calculateCurrentOffsetForPage ( page ). absoluteValue // We animate the scaleX + scaleY, between 85% and 100% lerp ( start = 0.85f , stop = 1f , fraction = 1f - pageOffset . coerceIn ( 0f , 1f ) ). also { scale -> scaleX = scale scaleY = scale } // We animate the alpha, between 50% and 100% alpha = lerp ( start = 0.5f , stop = 1f , fraction = 1f - pageOffset . coerceIn ( 0f , 1f ) ) } ) { // Card content } } Reacting to page changes \u00b6 The PagerState.currentPage property is updated whenever the selected page changes. You can use the snapshotFlow function to observe changes in a flow: val pagerState = rememberPagerState () LaunchedEffect ( pagerState ) { // Collect from the pager state a snapshotFlow reading the currentPage snapshotFlow { pagerState . currentPage }. collect { page -> AnalyticsService . sendPageSelectedEvent ( page ) } } VerticalPager ( count = 10 , state = pagerState , ) { page -> Text ( text = \"Page: $ page \" ) } Indicators \u00b6 We also publish a sibling library called pager-indicators which provides some simple indicator composables for use with HorizontalPager and VerticalPager . Your browser does not support the video tag. Pager indicators demo The HorizontalPagerWithIndicatorSample and VerticalPagerWithIndicatorSample show you how to use these. Integration with Tabs \u00b6 A common use-case for HorizontalPager is to be used in conjunction with a TabRow or ScrollableTabRow . Your browser does not support the video tag. HorizontalPager + TabRow Provided in the pager-indicators library is a modifier which can be used on a tab indicator like so: val pagerState = rememberPagerState () TabRow ( // Our selected tab is our current page selectedTabIndex = pagerState . currentPage , // Override the indicator, using the provided pagerTabIndicatorOffset modifier indicator = { tabPositions -> TabRowDefaults . Indicator ( Modifier . pagerTabIndicatorOffset ( pagerState , tabPositions ) ) } ) { // Add tabs for all of our pages pages . forEachIndexed { index , title -> Tab ( text = { Text ( title ) }, selected = pagerState . currentPage == index , onClick = { /* TODO */ }, ) } } HorizontalPager ( count = pages . size , state = pagerState , ) { page -> // TODO: page content } Changes in v0.19.0 \u00b6 In v0.19.0 both HorizontalPager and VerticalPager were re-written to be based on LazyRow and LazyColumn respectively. As part of this change, a number of feature and API changes were made: PagerState \u00b6 The pageCount parameter on rememberPagerState() has been removed, replaced with the count parameter on HorizontalPager() and VerticalPager() . The animationSpec , initialVelocity and skipPages parameters on animateScrollToPage() have been removed. The lazy components handle this automatically. HorizontalPager & VerticalPager \u00b6 Ability to set contentPadding (see above ). Ability to specify a key for each page. The horizontalAlignment parameter on HorizontalPager , and the verticalAlignment parameter on VerticalPager have been removed. A similar effect can be implemented with an appropriate content padding (see above ). The infiniteLooping parameter and feature have been removed. A sample demonstrating how to achieve this effect can be found here . The offscreenLimit parameter has been removed. We no longer have control of what items are laid out 'off screen'. The dragEnabled parameter has removed. PagerScope (the page item scope) no longer implements BoxScope . Usage \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-pager:<version>\" // If using indicators, also depend on implementation \"com.google.accompanist:accompanist-pager-indicators:<version>\" } Library Snapshots \u00b6 Snapshots of the current development version of this library are available, which track the latest commit. See here for more information on how to use them. Contributions \u00b6 Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though. License \u00b6 Copyright 2021 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Guide"},{"location":"pager/#pager-layouts","text":"A library which provides paging layouts for Jetpack Compose. If you've used Android's ViewPager before, it has similar properties. Warning The pager layouts are currently experimental and the APIs could change at any time. All of the APIs are marked with the @ExperimentalPagerApi annotation.","title":"Pager layouts"},{"location":"pager/#horizontalpager","text":"HorizontalPager is a layout which lays out items in a horizontal row, and allows the user to horizontally swipe between pages. Your browser does not support the video tag. HorizontalPager demo The simplest usage looks like the following: // Display 10 items HorizontalPager ( count = 10 ) { page -> // Our page content Text ( text = \"Page: $ page \" , modifier = Modifier . fillMaxWidth () ) } If you want to jump to a specific page, you either call call pagerState.scrollToPage(index) or pagerState.animateScrollToPage(index) method in a CoroutineScope . val pagerState = rememberPagerState () HorizontalPager ( count = 10 , state = pagerState ) { page -> // ...page content } // Later, scroll to page 2 scope . launch { pagerState . scrollToPage ( 2 ) }","title":"HorizontalPager"},{"location":"pager/#verticalpager","text":"VerticalPager is very similar to HorizontalPager but items are laid out vertically, and react to vertical swipes: Your browser does not support the video tag. VerticalPager demo // Display 10 items VerticalPager ( count = 10 ) { page -> // Our page content Text ( text = \"Page: $ page \" , modifier = Modifier . fillMaxWidth () ) }","title":"VerticalPager"},{"location":"pager/#lazy-creation","text":"Pages in both HorizontalPager and VerticalPager are lazily composed and laid-out as required by the layout. As the user scrolls through pages, any pages which are no longer required are removed from the content. Under the covers, HorizontalPager use LazyRow , and VerticalPager uses LazyColumn .","title":"Lazy creation"},{"location":"pager/#content-padding","text":"HorizontalPager and VerticalPager both support the setting of content padding, which allows you to influence the maximum size and alignment of pages. You can see how different content padding values affect a HorizontalPager below: start = 64.dp Setting the start padding has the effect of aligning the pages towards the end. HorizontalPager ( count = 4 , contentPadding = PaddingValues ( start = 64. dp ), ) { page -> // page content } horizontal = 32.dp Setting both the start and end padding to the same value has the effect of centering the item horizontally. HorizontalPager ( count = 4 , contentPadding = PaddingValues ( horizontal = 32. dp ), ) { page -> // page content } end = 64.dp Setting the end padding has the effect of aligning the pages towards the start. HorizontalPager ( count = 4 , contentPadding = PaddingValues ( end = 64. dp ), ) { page -> // page content } Similar effects for VerticalPager can be achieved by setting the top and bottom values. The value 32.dp is only used here as an example, you can set each of the padding dimensions to whatever value you wish.","title":"Content Padding"},{"location":"pager/#item-scroll-effects","text":"A common use-case is to apply effects to your pager items, using the scroll position to drive those effects. The HorizontalPagerTransitionSample demonstrates how this can be done: Your browser does not support the video tag. Item effects demo The scope provided to your pager content allows apps to easily reference the currentPage and currentPageOffset . The effects can then be calculated using those values. We provide the calculateCurrentOffsetForPage() extension functions to support calculation of the 'offset' for a given page: import com.google.accompanist.pager.calculateCurrentOffsetForPage HorizontalPager ( count = 4 ) { page -> Card ( Modifier . graphicsLayer { // Calculate the absolute offset for the current page from the // scroll position. We use the absolute value which allows us to mirror // any effects for both directions val pageOffset = calculateCurrentOffsetForPage ( page ). absoluteValue // We animate the scaleX + scaleY, between 85% and 100% lerp ( start = 0.85f , stop = 1f , fraction = 1f - pageOffset . coerceIn ( 0f , 1f ) ). also { scale -> scaleX = scale scaleY = scale } // We animate the alpha, between 50% and 100% alpha = lerp ( start = 0.5f , stop = 1f , fraction = 1f - pageOffset . coerceIn ( 0f , 1f ) ) } ) { // Card content } }","title":"Item scroll effects"},{"location":"pager/#reacting-to-page-changes","text":"The PagerState.currentPage property is updated whenever the selected page changes. You can use the snapshotFlow function to observe changes in a flow: val pagerState = rememberPagerState () LaunchedEffect ( pagerState ) { // Collect from the pager state a snapshotFlow reading the currentPage snapshotFlow { pagerState . currentPage }. collect { page -> AnalyticsService . sendPageSelectedEvent ( page ) } } VerticalPager ( count = 10 , state = pagerState , ) { page -> Text ( text = \"Page: $ page \" ) }","title":"Reacting to page changes"},{"location":"pager/#indicators","text":"We also publish a sibling library called pager-indicators which provides some simple indicator composables for use with HorizontalPager and VerticalPager . Your browser does not support the video tag. Pager indicators demo The HorizontalPagerWithIndicatorSample and VerticalPagerWithIndicatorSample show you how to use these.","title":"Indicators"},{"location":"pager/#integration-with-tabs","text":"A common use-case for HorizontalPager is to be used in conjunction with a TabRow or ScrollableTabRow . Your browser does not support the video tag. HorizontalPager + TabRow Provided in the pager-indicators library is a modifier which can be used on a tab indicator like so: val pagerState = rememberPagerState () TabRow ( // Our selected tab is our current page selectedTabIndex = pagerState . currentPage , // Override the indicator, using the provided pagerTabIndicatorOffset modifier indicator = { tabPositions -> TabRowDefaults . Indicator ( Modifier . pagerTabIndicatorOffset ( pagerState , tabPositions ) ) } ) { // Add tabs for all of our pages pages . forEachIndexed { index , title -> Tab ( text = { Text ( title ) }, selected = pagerState . currentPage == index , onClick = { /* TODO */ }, ) } } HorizontalPager ( count = pages . size , state = pagerState , ) { page -> // TODO: page content }","title":"Integration with Tabs"},{"location":"pager/#changes-in-v0190","text":"In v0.19.0 both HorizontalPager and VerticalPager were re-written to be based on LazyRow and LazyColumn respectively. As part of this change, a number of feature and API changes were made:","title":"Changes in v0.19.0"},{"location":"pager/#pagerstate","text":"The pageCount parameter on rememberPagerState() has been removed, replaced with the count parameter on HorizontalPager() and VerticalPager() . The animationSpec , initialVelocity and skipPages parameters on animateScrollToPage() have been removed. The lazy components handle this automatically.","title":"PagerState"},{"location":"pager/#horizontalpager-verticalpager","text":"Ability to set contentPadding (see above ). Ability to specify a key for each page. The horizontalAlignment parameter on HorizontalPager , and the verticalAlignment parameter on VerticalPager have been removed. A similar effect can be implemented with an appropriate content padding (see above ). The infiniteLooping parameter and feature have been removed. A sample demonstrating how to achieve this effect can be found here . The offscreenLimit parameter has been removed. We no longer have control of what items are laid out 'off screen'. The dragEnabled parameter has removed. PagerScope (the page item scope) no longer implements BoxScope .","title":"HorizontalPager &amp; VerticalPager"},{"location":"pager/#usage","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-pager:<version>\" // If using indicators, also depend on implementation \"com.google.accompanist:accompanist-pager-indicators:<version>\" }","title":"Usage"},{"location":"pager/#library-snapshots","text":"Snapshots of the current development version of this library are available, which track the latest commit. See here for more information on how to use them.","title":"Library Snapshots"},{"location":"pager/#contributions","text":"Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though.","title":"Contributions"},{"location":"pager/#license","text":"Copyright 2021 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"permissions/","text":"Jetpack Compose Permissions \u00b6 A library which provides Android runtime permissions support for Jetpack Compose. Warning The permission APIs are currently experimental and they could change at any time. All of the APIs are marked with the @ExperimentalPermissionsApi annotation. Usage \u00b6 rememberPermissionState and rememberMultiplePermissionsState APIs \u00b6 The rememberPermissionState(permission: String) API allows you to request a certain permission to the user and check for the status of the permission. rememberMultiplePermissionsState(permissions: List<String>) offers the same but for multiple permissions at the same time. Both APIs expose properties for you to follow the workflow as described in the permissions documentation . Caution The call to the method that requests the permission to the user (e.g. PermissionState.launchPermissionRequest() ) needs to be invoked from a non-composable scope. For example, from a side-effect or from a non-composable callback such as a Button 's onClick lambda. The following code exercises the permission request workflow . @Composable private fun FeatureThatRequiresCameraPermission () { // Camera permission state val cameraPermissionState = rememberPermissionState ( android . Manifest . permission . CAMERA ) when ( cameraPermissionState . status ) { // If the camera permission is granted, then show screen with the feature enabled PermissionStatus . Granted -> { Text ( \"Camera permission Granted\" ) } is PermissionStatus . Denied -> { Column { val textToShow = if ( cameraPermissionState . status . shouldShowRationale ) { // If the user has denied the permission but the rationale can be shown, // then gently explain why the app requires this permission \"The camera is important for this app. Please grant the permission.\" } else { // If it's the first time the user lands on this feature, or the user // doesn't want to be asked again for this permission, explain that the // permission is required \"Camera permission required for this feature to be available. \" + \"Please grant the permission\" } Text ( textToShow ) Button ( onClick = { cameraPermissionState . launchPermissionRequest () }) { Text ( \"Request permission\" ) } } } } } For more examples, refer to the samples . Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-permissions:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Guide"},{"location":"permissions/#jetpack-compose-permissions","text":"A library which provides Android runtime permissions support for Jetpack Compose. Warning The permission APIs are currently experimental and they could change at any time. All of the APIs are marked with the @ExperimentalPermissionsApi annotation.","title":"Jetpack Compose Permissions"},{"location":"permissions/#usage","text":"","title":"Usage"},{"location":"permissions/#rememberpermissionstate-and-remembermultiplepermissionsstate-apis","text":"The rememberPermissionState(permission: String) API allows you to request a certain permission to the user and check for the status of the permission. rememberMultiplePermissionsState(permissions: List<String>) offers the same but for multiple permissions at the same time. Both APIs expose properties for you to follow the workflow as described in the permissions documentation . Caution The call to the method that requests the permission to the user (e.g. PermissionState.launchPermissionRequest() ) needs to be invoked from a non-composable scope. For example, from a side-effect or from a non-composable callback such as a Button 's onClick lambda. The following code exercises the permission request workflow . @Composable private fun FeatureThatRequiresCameraPermission () { // Camera permission state val cameraPermissionState = rememberPermissionState ( android . Manifest . permission . CAMERA ) when ( cameraPermissionState . status ) { // If the camera permission is granted, then show screen with the feature enabled PermissionStatus . Granted -> { Text ( \"Camera permission Granted\" ) } is PermissionStatus . Denied -> { Column { val textToShow = if ( cameraPermissionState . status . shouldShowRationale ) { // If the user has denied the permission but the rationale can be shown, // then gently explain why the app requires this permission \"The camera is important for this app. Please grant the permission.\" } else { // If it's the first time the user lands on this feature, or the user // doesn't want to be asked again for this permission, explain that the // permission is required \"Camera permission required for this feature to be available. \" + \"Please grant the permission\" } Text ( textToShow ) Button ( onClick = { cameraPermissionState . launchPermissionRequest () }) { Text ( \"Request permission\" ) } } } } } For more examples, refer to the samples .","title":"rememberPermissionState and rememberMultiplePermissionsState APIs"},{"location":"permissions/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-permissions:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Download"},{"location":"placeholder/","text":"Placeholder \u00b6 A library which provides a modifier for display 'placeholder' UI while content is loading. More information on the UX provided by this library can be found on the Material Theming Placeholder UI guidelines. There are actually two versions of the library available: Placeholder Foundation : Provides the base functionality and depends on Jetpack Compose Foundation. This version requires the app to provide all of the colors to display. Placeholder Material . This uses the foundation library above, but also provides sensible default colors using your app's Material color palette. Tip You only need to use one of the libraries, and most apps should use Placeholder Material . The APIs of the libraries are (mostly) equivalent with only the imports being different. Where possible we have provided equivalent code samples below. Basic usage \u00b6 At the most basic usage, the modifier will draw a shape over your composable content, filled with the provided color. Placeholder Material import com.google.accompanist.placeholder.material.placeholder Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true ) ) Placeholder Foundation import com.google.accompanist.placeholder.placeholder Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , color = Color . Gray , // optional, defaults to RectangleShape shape = RoundedCornerShape ( 4. dp ), ) ) Placeholder highlights \u00b6 The library also provides some 'highlight' animations to entertain the user while they are waiting. There are two provided by the library, but you can also provide your own. Fade \u00b6 This highlight fades a color over the entire placeholder in and out. Your browser does not support the video tag. Placeholder Fade demo Placeholder Material import com.google.accompanist.placeholder.PlaceholderHighlight import com.google.accompanist.placeholder.material.placeholder import com.google.accompanist.placeholder.material.fade Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , highlight = PlaceholderHighlight . fade (), ) ) Placeholder Foundation import com.google.accompanist.placeholder.PlaceholderHighlight import com.google.accompanist.placeholder.placeholder import com.google.accompanist.placeholder.fade Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , color = Color . Gray , // optional, defaults to RectangleShape shape = RoundedCornerShape ( 4. dp ), highlight = PlaceholderHighlight . fade ( highlightColor = Color . White , ), ) ) Shimmer \u00b6 This displays a gradient shimmer effect which emanates from the top-start corner. Your browser does not support the video tag. Placeholder Shimmer demo Placeholder Material import com.google.accompanist.placeholder.PlaceholderHighlight import com.google.accompanist.placeholder.material.placeholder import com.google.accompanist.placeholder.material.shimmer Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , highlight = PlaceholderHighlight . shimmer (), ) ) Placeholder Foundation import com.google.accompanist.placeholder.PlaceholderHighlight import com.google.accompanist.placeholder.placeholder import com.google.accompanist.placeholder.shimmer Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , color = Color . Gray , // optional, defaults to RectangleShape shape = RoundedCornerShape ( 4. dp ), highlight = PlaceholderHighlight . shimmer ( highlightColor = Color . White , ), ) ) Usage \u00b6 repositories { mavenCentral () } dependencies { // If you're using Material, use accompanist-placeholder-material implementation \"com.google.accompanist:accompanist-placeholder-material:<version>\" // Otherwise use the foundation version implementation \"com.google.accompanist:accompanist-placeholder:<version>\" } Library Snapshots \u00b6 Snapshots of the current development version of this library are available, which track the latest commit. See here for more information on how to use them. Contributions \u00b6 Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though. License \u00b6 Copyright 2021 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Guide"},{"location":"placeholder/#placeholder","text":"A library which provides a modifier for display 'placeholder' UI while content is loading. More information on the UX provided by this library can be found on the Material Theming Placeholder UI guidelines. There are actually two versions of the library available: Placeholder Foundation : Provides the base functionality and depends on Jetpack Compose Foundation. This version requires the app to provide all of the colors to display. Placeholder Material . This uses the foundation library above, but also provides sensible default colors using your app's Material color palette. Tip You only need to use one of the libraries, and most apps should use Placeholder Material . The APIs of the libraries are (mostly) equivalent with only the imports being different. Where possible we have provided equivalent code samples below.","title":"Placeholder"},{"location":"placeholder/#basic-usage","text":"At the most basic usage, the modifier will draw a shape over your composable content, filled with the provided color. Placeholder Material import com.google.accompanist.placeholder.material.placeholder Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true ) ) Placeholder Foundation import com.google.accompanist.placeholder.placeholder Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , color = Color . Gray , // optional, defaults to RectangleShape shape = RoundedCornerShape ( 4. dp ), ) )","title":"Basic usage"},{"location":"placeholder/#placeholder-highlights","text":"The library also provides some 'highlight' animations to entertain the user while they are waiting. There are two provided by the library, but you can also provide your own.","title":"Placeholder highlights"},{"location":"placeholder/#fade","text":"This highlight fades a color over the entire placeholder in and out. Your browser does not support the video tag. Placeholder Fade demo Placeholder Material import com.google.accompanist.placeholder.PlaceholderHighlight import com.google.accompanist.placeholder.material.placeholder import com.google.accompanist.placeholder.material.fade Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , highlight = PlaceholderHighlight . fade (), ) ) Placeholder Foundation import com.google.accompanist.placeholder.PlaceholderHighlight import com.google.accompanist.placeholder.placeholder import com.google.accompanist.placeholder.fade Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , color = Color . Gray , // optional, defaults to RectangleShape shape = RoundedCornerShape ( 4. dp ), highlight = PlaceholderHighlight . fade ( highlightColor = Color . White , ), ) )","title":"Fade"},{"location":"placeholder/#shimmer","text":"This displays a gradient shimmer effect which emanates from the top-start corner. Your browser does not support the video tag. Placeholder Shimmer demo Placeholder Material import com.google.accompanist.placeholder.PlaceholderHighlight import com.google.accompanist.placeholder.material.placeholder import com.google.accompanist.placeholder.material.shimmer Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , highlight = PlaceholderHighlight . shimmer (), ) ) Placeholder Foundation import com.google.accompanist.placeholder.PlaceholderHighlight import com.google.accompanist.placeholder.placeholder import com.google.accompanist.placeholder.shimmer Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , color = Color . Gray , // optional, defaults to RectangleShape shape = RoundedCornerShape ( 4. dp ), highlight = PlaceholderHighlight . shimmer ( highlightColor = Color . White , ), ) )","title":"Shimmer"},{"location":"placeholder/#usage","text":"repositories { mavenCentral () } dependencies { // If you're using Material, use accompanist-placeholder-material implementation \"com.google.accompanist:accompanist-placeholder-material:<version>\" // Otherwise use the foundation version implementation \"com.google.accompanist:accompanist-placeholder:<version>\" }","title":"Usage"},{"location":"placeholder/#library-snapshots","text":"Snapshots of the current development version of this library are available, which track the latest commit. See here for more information on how to use them.","title":"Library Snapshots"},{"location":"placeholder/#contributions","text":"Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though.","title":"Contributions"},{"location":"placeholder/#license","text":"Copyright 2021 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"swiperefresh/","text":"Swipe Refresh for Jetpack Compose \u00b6 A library which provides a layout which provides the swipe-to-refresh UX pattern, similar to Android's SwipeRefreshLayout . Your browser does not support the video tag. SwipeRefresh demo Usage \u00b6 To implement this UX pattern there are two key APIs which are needed: SwipeRefresh , which is provides the layout, and rememberSwipeRefreshState() which provides some remembered state. The basic usage of a SwipeRefresh using a ViewModel looks like so: val viewModel : MyViewModel = viewModel () val isRefreshing by viewModel . isRefreshing . collectAsState () SwipeRefresh ( state = rememberSwipeRefreshState ( isRefreshing ), onRefresh = { viewModel . refresh () }, ) { LazyColumn { items ( 30 ) { index -> // TODO: list items } } } The full example, including the view model implementation can be found here . The content needs to be 'vertically scrollable' for SwipeRefresh() to be able to react to swipe gestures. Layouts such as LazyColumn are automatically vertically scrollable, but others such as Column or LazyRow are not. In those instances, you can provide a Modifier.verticalScroll modifier to that content like so: SwipeRefresh ( // ... ) { Column ( Modifier . verticalScroll ( rememberScrollState ())) { // content } } Indicating a refresh without swiping \u00b6 As this library is built with a separate state object, it's easy to display a refreshing indicator without a swipe to triggering it. The unrealistic example below displays a forever refreshing indicator: val swipeRefreshState = rememberSwipeRefreshState ( true ) SwipeRefresh ( state = swipeRefreshState , onRefresh = { /* todo */ }, ) { LazyColumn { items ( 30 ) { index -> // TODO: list items } } } Indicator \u00b6 The library provides a default indicator: SwipeRefreshIndicator() , which SwipeRefresh uses automatically. You can customize the default indicator, and even provide your own indicator content using the indicator slot. Customizing default indicator \u00b6 To customize the default indicator, we can provide our own indicator content block, to call SwipeRefreshIndicator() with customized parameters: Sample SwipeRefresh ( state = /* ... */ , onRefresh = /* ... */ , indicator = { state , trigger -> SwipeRefreshIndicator ( // Pass the SwipeRefreshState + trigger through state = state , refreshTriggerDistance = trigger , // Enable the scale animation scale = true , // Change the color and shape backgroundColor = MaterialTheme . colors . primary , shape = MaterialTheme . shapes . small , ) } ) Demo video Your browser does not support the video tag. Tweaked indicator demo Custom indicator \u00b6 As mentioned, you can also provide your own custom indicator content. A SwipeRefreshState is provided to indicator content slot, which contains the information necessary to react to a swipe refresh gesture. An example of a custom indicator is provided here . Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-swiperefresh:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Guide"},{"location":"swiperefresh/#swipe-refresh-for-jetpack-compose","text":"A library which provides a layout which provides the swipe-to-refresh UX pattern, similar to Android's SwipeRefreshLayout . Your browser does not support the video tag. SwipeRefresh demo","title":"Swipe Refresh for Jetpack Compose"},{"location":"swiperefresh/#usage","text":"To implement this UX pattern there are two key APIs which are needed: SwipeRefresh , which is provides the layout, and rememberSwipeRefreshState() which provides some remembered state. The basic usage of a SwipeRefresh using a ViewModel looks like so: val viewModel : MyViewModel = viewModel () val isRefreshing by viewModel . isRefreshing . collectAsState () SwipeRefresh ( state = rememberSwipeRefreshState ( isRefreshing ), onRefresh = { viewModel . refresh () }, ) { LazyColumn { items ( 30 ) { index -> // TODO: list items } } } The full example, including the view model implementation can be found here . The content needs to be 'vertically scrollable' for SwipeRefresh() to be able to react to swipe gestures. Layouts such as LazyColumn are automatically vertically scrollable, but others such as Column or LazyRow are not. In those instances, you can provide a Modifier.verticalScroll modifier to that content like so: SwipeRefresh ( // ... ) { Column ( Modifier . verticalScroll ( rememberScrollState ())) { // content } }","title":"Usage"},{"location":"swiperefresh/#indicating-a-refresh-without-swiping","text":"As this library is built with a separate state object, it's easy to display a refreshing indicator without a swipe to triggering it. The unrealistic example below displays a forever refreshing indicator: val swipeRefreshState = rememberSwipeRefreshState ( true ) SwipeRefresh ( state = swipeRefreshState , onRefresh = { /* todo */ }, ) { LazyColumn { items ( 30 ) { index -> // TODO: list items } } }","title":"Indicating a refresh without swiping"},{"location":"swiperefresh/#indicator","text":"The library provides a default indicator: SwipeRefreshIndicator() , which SwipeRefresh uses automatically. You can customize the default indicator, and even provide your own indicator content using the indicator slot.","title":"Indicator"},{"location":"swiperefresh/#customizing-default-indicator","text":"To customize the default indicator, we can provide our own indicator content block, to call SwipeRefreshIndicator() with customized parameters: Sample SwipeRefresh ( state = /* ... */ , onRefresh = /* ... */ , indicator = { state , trigger -> SwipeRefreshIndicator ( // Pass the SwipeRefreshState + trigger through state = state , refreshTriggerDistance = trigger , // Enable the scale animation scale = true , // Change the color and shape backgroundColor = MaterialTheme . colors . primary , shape = MaterialTheme . shapes . small , ) } ) Demo video Your browser does not support the video tag. Tweaked indicator demo","title":"Customizing default indicator"},{"location":"swiperefresh/#custom-indicator","text":"As mentioned, you can also provide your own custom indicator content. A SwipeRefreshState is provided to indicator content slot, which contains the information necessary to react to a swipe refresh gesture. An example of a custom indicator is provided here .","title":"Custom indicator"},{"location":"swiperefresh/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-swiperefresh:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Download"},{"location":"systemuicontroller/","text":"System UI Controller for Jetpack Compose \u00b6 System UI Controller provides easy-to-use utilities for updating the System UI bar colors within Jetpack Compose. Usage \u00b6 To control the system UI in your composables, you need to get a SystemUiController instance. The library provides the rememberSystemUiController() function which returns an instance for the current system (currently only Android). In your layouts you can update the system bar colors like so: // Remember a SystemUiController val systemUiController = rememberSystemUiController () val useDarkIcons = ! isSystemInDarkTheme () DisposableEffect ( systemUiController , useDarkIcons ) { // Update all of the system bar colors to be transparent, and use // dark icons if we're in light theme systemUiController . setSystemBarsColor ( color = Color . Transparent , darkIcons = useDarkIcons ) // setStatusBarColor() and setNavigationBarColor() also exist onDispose {} } System bar icon colors \u00b6 The library automatically handles API level differences when running on Android devices. If we look at the example of status bar icons, Android only natively supports dark icons on API 23+. This library handles this by automatically altering the requested color with a scrim, to maintain contrast: Similar happens on navigation bar color, which is only available on API 26+. Modifying scrim logic \u00b6 The scrim logic can be modified if needed: systemUiController . setStatusBarColor ( color = Color . Transparent , darkIcons = true ) { requestedColor -> // TODO: return a darkened color to be used when the system doesn't // natively support dark icons } Samples \u00b6 For complete samples, check out the Insets samples which all use SystemUiController to set transparent system bars. Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-systemuicontroller:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Guide"},{"location":"systemuicontroller/#system-ui-controller-for-jetpack-compose","text":"System UI Controller provides easy-to-use utilities for updating the System UI bar colors within Jetpack Compose.","title":"System UI Controller for Jetpack Compose"},{"location":"systemuicontroller/#usage","text":"To control the system UI in your composables, you need to get a SystemUiController instance. The library provides the rememberSystemUiController() function which returns an instance for the current system (currently only Android). In your layouts you can update the system bar colors like so: // Remember a SystemUiController val systemUiController = rememberSystemUiController () val useDarkIcons = ! isSystemInDarkTheme () DisposableEffect ( systemUiController , useDarkIcons ) { // Update all of the system bar colors to be transparent, and use // dark icons if we're in light theme systemUiController . setSystemBarsColor ( color = Color . Transparent , darkIcons = useDarkIcons ) // setStatusBarColor() and setNavigationBarColor() also exist onDispose {} }","title":"Usage"},{"location":"systemuicontroller/#system-bar-icon-colors","text":"The library automatically handles API level differences when running on Android devices. If we look at the example of status bar icons, Android only natively supports dark icons on API 23+. This library handles this by automatically altering the requested color with a scrim, to maintain contrast: Similar happens on navigation bar color, which is only available on API 26+.","title":"System bar icon colors"},{"location":"systemuicontroller/#modifying-scrim-logic","text":"The scrim logic can be modified if needed: systemUiController . setStatusBarColor ( color = Color . Transparent , darkIcons = true ) { requestedColor -> // TODO: return a darkened color to be used when the system doesn't // natively support dark icons }","title":"Modifying scrim logic"},{"location":"systemuicontroller/#samples","text":"For complete samples, check out the Insets samples which all use SystemUiController to set transparent system bars.","title":"Samples"},{"location":"systemuicontroller/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-systemuicontroller:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Download"},{"location":"updating/","text":"Updating & releasing Accompanist \u00b6 This doc is mostly for maintainers. New features & bugfixes \u00b6 All new features should be uploaded as PRs against the main branch. Once merged into main , they will be automatically merged into the snapshot branch. Jetpack Compose Snapshots \u00b6 We publish snapshot versions of Accompanist, which depend on a SNAPSHOT versions of Jetpack Compose. These are built from the snapshot branch. Updating to a newer Compose snapshot \u00b6 As mentioned above, updating to a new Compose snapshot is done by submitting a new PR against the snapshot branch: git checkout snapshot && git pull # Create branch for PR git checkout -b update_snapshot Now edit the project to depend on the new Compose SNAPSHOT version: Edit /gradle/libs.versions.toml : Under [versions] : Update the composesnapshot property to be the snapshot number Ensure that the compose property is correct Make sure the project builds and test pass: ./gradlew check Now git commit the changes and push to GitHub. Finally create a PR (with the base branch as snapshot ) and send for review. Releasing \u00b6 Once the next Jetpack Compose version is out, we're ready to push a new release: #1: Merge snapshot into main \u00b6 First we merge the snapshot branch into main : git checkout snapshot && git pull git checkout main && git pull # Create branch for PR git checkout -b main_snapshot_merge # Merge in the snapshot branch git merge snapshot #2: Update dependencies \u00b6 Edit /gradle/libs.versions.toml : Under [versions] : Update the composesnapshot property to a single character (usually - ). This disables the snapshot repository. Update the compose property to match the new release (i.e. 1.0.0-beta06 ) Make sure the project builds and test pass: ./gradlew check Commit the changes. #3: Bump the version number \u00b6 Edit gradle.properties : Update the VERSION_NAME property and remove the -SNAPSHOT suffix. Commit the changes, using the commit message containing the new version name. #4: Push to GitHub \u00b6 Push the branch to GitHub and create a PR against the main branch, and send for review. Once approved and merged, it will be automatically deployed to Maven Central. #5: Create release \u00b6 Once the above PR has been approved and merged, we need to create the GitHub release: Open up the Releases page. At the top you should see a 'Draft' release, auto populated with any PRs since the last release. Click 'Edit'. Make sure that the version number matches what we released (the tool guesses but is not always correct). Double check everything, then press 'Publish release'. At this point the release is published. This will trigger the docs action to run, which will auto-deploy a new version of the website . #6: Prepare the next development version \u00b6 The current release is now finished, but we need to update the version for the next development version: Edit gradle.properties : Update the VERSION_NAME property, by increasing the version number, and adding the -SNAPSHOT suffix. Example: released version: 0.3.0 . Update to 0.3.1-SNAPSHOT git commit and push to main . Finally, merge all of these changes back to snapshot : git checkout snapshot && git pull git merge main git push","title":"Update guide"},{"location":"updating/#updating-releasing-accompanist","text":"This doc is mostly for maintainers.","title":"Updating &amp; releasing Accompanist"},{"location":"updating/#new-features-bugfixes","text":"All new features should be uploaded as PRs against the main branch. Once merged into main , they will be automatically merged into the snapshot branch.","title":"New features &amp; bugfixes"},{"location":"updating/#jetpack-compose-snapshots","text":"We publish snapshot versions of Accompanist, which depend on a SNAPSHOT versions of Jetpack Compose. These are built from the snapshot branch.","title":"Jetpack Compose Snapshots"},{"location":"updating/#updating-to-a-newer-compose-snapshot","text":"As mentioned above, updating to a new Compose snapshot is done by submitting a new PR against the snapshot branch: git checkout snapshot && git pull # Create branch for PR git checkout -b update_snapshot Now edit the project to depend on the new Compose SNAPSHOT version: Edit /gradle/libs.versions.toml : Under [versions] : Update the composesnapshot property to be the snapshot number Ensure that the compose property is correct Make sure the project builds and test pass: ./gradlew check Now git commit the changes and push to GitHub. Finally create a PR (with the base branch as snapshot ) and send for review.","title":"Updating to a newer Compose snapshot"},{"location":"updating/#releasing","text":"Once the next Jetpack Compose version is out, we're ready to push a new release:","title":"Releasing"},{"location":"updating/#1-merge-snapshot-into-main","text":"First we merge the snapshot branch into main : git checkout snapshot && git pull git checkout main && git pull # Create branch for PR git checkout -b main_snapshot_merge # Merge in the snapshot branch git merge snapshot","title":"#1: Merge snapshot into main"},{"location":"updating/#2-update-dependencies","text":"Edit /gradle/libs.versions.toml : Under [versions] : Update the composesnapshot property to a single character (usually - ). This disables the snapshot repository. Update the compose property to match the new release (i.e. 1.0.0-beta06 ) Make sure the project builds and test pass: ./gradlew check Commit the changes.","title":"#2: Update dependencies"},{"location":"updating/#3-bump-the-version-number","text":"Edit gradle.properties : Update the VERSION_NAME property and remove the -SNAPSHOT suffix. Commit the changes, using the commit message containing the new version name.","title":"#3: Bump the version number"},{"location":"updating/#4-push-to-github","text":"Push the branch to GitHub and create a PR against the main branch, and send for review. Once approved and merged, it will be automatically deployed to Maven Central.","title":"#4: Push to GitHub"},{"location":"updating/#5-create-release","text":"Once the above PR has been approved and merged, we need to create the GitHub release: Open up the Releases page. At the top you should see a 'Draft' release, auto populated with any PRs since the last release. Click 'Edit'. Make sure that the version number matches what we released (the tool guesses but is not always correct). Double check everything, then press 'Publish release'. At this point the release is published. This will trigger the docs action to run, which will auto-deploy a new version of the website .","title":"#5: Create release"},{"location":"updating/#6-prepare-the-next-development-version","text":"The current release is now finished, but we need to update the version for the next development version: Edit gradle.properties : Update the VERSION_NAME property, by increasing the version number, and adding the -SNAPSHOT suffix. Example: released version: 0.3.0 . Update to 0.3.1-SNAPSHOT git commit and push to main . Finally, merge all of these changes back to snapshot : git checkout snapshot && git pull git merge main git push","title":"#6: Prepare the next development version"},{"location":"using-snapshot-version/","text":"Using a Snapshot Version of the Library \u00b6 If you would like to depend on the cutting edge version of the Accompanist library, you can use the snapshot versions that are published to Sonatype OSSRH 's snapshot repository. These are updated on every commit to main . To do so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'com.google.accompanist:accompanist-coil:XXX-SNAPSHOT' } You might see a number of different versioned snapshots. If we use an example: 0.3.0-SNAPSHOT is a build from the main branch, and depends on the latest tagged Jetpack Compose release (i.e. alpha03 ). 0.3.0.compose-6574163-SNAPSHOT is a build from the snapshot branch. This depends on the SNAPSHOT build of Jetpack Compose from build 6574163 . You should only use these if you are using Jetpack Compose snapshot versions (see below). Using Jetpack Compose Snapshots \u00b6 If you're using SNAPSHOT versions of the androidx.compose libraries, you might run into issues with the current stable Accompanist release forcing an older version of those libraries. We publish snapshot versions of Accompanist which depend on recent Jetpack Compose SNAPSHOT repositories. To find a recent build, look through the snapshot repository for any versions in the scheme x.x.x.compose-YYYY-SNAPSHOT (for example: 0.3.0.compose-6574163-SNAPSHOT ). The YYYY in the scheme is the snapshot build being used from AndroidX (from the example: build 6574163 ). You can then use it like so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'com.google.accompanist:accompanist-coil:XXXX.compose-YYYYY-SNAPSHOT' } These builds are updated regularly, but there's no guarantee that we will create one for a given snapshot number. Note: you might also see versions in the scheme x.x.x.ui-YYYY-SNAPSHOT . These are the same, just using an older suffix.","title":"Snapshots"},{"location":"using-snapshot-version/#using-a-snapshot-version-of-the-library","text":"If you would like to depend on the cutting edge version of the Accompanist library, you can use the snapshot versions that are published to Sonatype OSSRH 's snapshot repository. These are updated on every commit to main . To do so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'com.google.accompanist:accompanist-coil:XXX-SNAPSHOT' } You might see a number of different versioned snapshots. If we use an example: 0.3.0-SNAPSHOT is a build from the main branch, and depends on the latest tagged Jetpack Compose release (i.e. alpha03 ). 0.3.0.compose-6574163-SNAPSHOT is a build from the snapshot branch. This depends on the SNAPSHOT build of Jetpack Compose from build 6574163 . You should only use these if you are using Jetpack Compose snapshot versions (see below).","title":"Using a Snapshot Version of the Library"},{"location":"using-snapshot-version/#using-jetpack-compose-snapshots","text":"If you're using SNAPSHOT versions of the androidx.compose libraries, you might run into issues with the current stable Accompanist release forcing an older version of those libraries. We publish snapshot versions of Accompanist which depend on recent Jetpack Compose SNAPSHOT repositories. To find a recent build, look through the snapshot repository for any versions in the scheme x.x.x.compose-YYYY-SNAPSHOT (for example: 0.3.0.compose-6574163-SNAPSHOT ). The YYYY in the scheme is the snapshot build being used from AndroidX (from the example: build 6574163 ). You can then use it like so: repositories { // ... maven { url 'https://oss.sonatype.org/content/repositories/snapshots' } } dependencies { // Check the latest SNAPSHOT version from the link above classpath 'com.google.accompanist:accompanist-coil:XXXX.compose-YYYYY-SNAPSHOT' } These builds are updated regularly, but there's no guarantee that we will create one for a given snapshot number. Note: you might also see versions in the scheme x.x.x.ui-YYYY-SNAPSHOT . These are the same, just using an older suffix.","title":"Using Jetpack Compose Snapshots"},{"location":"web/","text":"WebView wrapper for Jetpack Compose \u00b6 A library which provides a Jetpack Compose wrapper around Android's WebView. Usage \u00b6 To implement this wrapper there are two key APIs which are needed: WebView , which is provides the layout, and rememberWebViewState(url) which provides some remembered state including the URL to display. The basic usage is as follows: val state = rememberWebViewState ( \"https://example.com\" ) WebView ( state ) This will display a WebView in your Compose layout that shows the URL provided. There is a larger sample in the sample app which can be found here . This sample also shows how to show a loading state. WebView settings including JavaScript \u00b6 By default, JavaScript is disabled in the WebView. To enable it or any other settings you can use the onCreated callback. WebView ( state = webViewState , onCreated = { it . settings . javaScriptEnabled = true } ) Capturing back presses \u00b6 By default the WebView will capture back presses/swipes when relevant and navigate the WebView back. This can be disabled via the parameter on the Composable. WebView ( ... captureBackPresses = false ) Using a subclass of WebView \u00b6 If you want to use a subclass of WebView , or simply require more control over its instantiation, you can provide a factory. WebView ( ... factory = { context -> CustomWebView ( context ) } ) Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-webview:<version>\" }","title":"Guide"},{"location":"web/#webview-wrapper-for-jetpack-compose","text":"A library which provides a Jetpack Compose wrapper around Android's WebView.","title":"WebView wrapper for Jetpack Compose"},{"location":"web/#usage","text":"To implement this wrapper there are two key APIs which are needed: WebView , which is provides the layout, and rememberWebViewState(url) which provides some remembered state including the URL to display. The basic usage is as follows: val state = rememberWebViewState ( \"https://example.com\" ) WebView ( state ) This will display a WebView in your Compose layout that shows the URL provided. There is a larger sample in the sample app which can be found here . This sample also shows how to show a loading state.","title":"Usage"},{"location":"web/#webview-settings-including-javascript","text":"By default, JavaScript is disabled in the WebView. To enable it or any other settings you can use the onCreated callback. WebView ( state = webViewState , onCreated = { it . settings . javaScriptEnabled = true } )","title":"WebView settings including JavaScript"},{"location":"web/#capturing-back-presses","text":"By default the WebView will capture back presses/swipes when relevant and navigate the WebView back. This can be disabled via the parameter on the Composable. WebView ( ... captureBackPresses = false )","title":"Capturing back presses"},{"location":"web/#using-a-subclass-of-webview","text":"If you want to use a subclass of WebView , or simply require more control over its instantiation, you can provide a factory. WebView ( ... factory = { context -> CustomWebView ( context ) } )","title":"Using a subclass of WebView"},{"location":"web/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-webview:<version>\" }","title":"Download"}]}